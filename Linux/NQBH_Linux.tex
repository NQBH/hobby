\documentclass[oneside]{book}
\usepackage[backend=biber,natbib=true,style=authoryear]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[vietnamese,english]{babel}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,mathtools,float,graphicx}
\usepackage[inline]{enumitem}
\allowdisplaybreaks
\numberwithin{equation}{section}
\newtheorem{assumption}{Assumption}[chapter]
\newtheorem{conjecture}{Conjecture}[chapter]
\newtheorem{corollary}{Corollary}[chapter]
\newtheorem{definition}{Definition}[chapter]
\newtheorem{example}{Example}[chapter]
\newtheorem{lemma}{Lemma}[chapter]
\newtheorem{notation}{Notation}[chapter]
\newtheorem{principle}{Principle}[chapter]
\newtheorem{problem}{Problem}[chapter]
\newtheorem{proposition}{Proposition}[chapter]
\newtheorem{question}{Question}[chapter]
\newtheorem{remark}{Remark}[chapter]
\newtheorem{theorem}{Theorem}[chapter]
\usepackage[left=0.5in,right=0.5in,top=1.5cm,bottom=1.5cm]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\lhead{\small Sect.~\thesection}
\rhead{\small\nouppercase{\leftmark}}
\renewcommand{\sectionmark}[1]{\markboth{#1}{}}
\cfoot{\thepage}
\def\labelitemii{$\circ$}

\title{Linux}
\author{\selectlanguage{vietnamese} Nguyễn Quản Bá Hồng\footnote{Independent Researcher, Ben Tre City, Vietnam\\e-mail: \texttt{nguyenquanbahong@gmail.com}; website: \url{https://nqbh.github.io}.}}
\date{\today}

\begin{document}
\maketitle
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{3}
\tableofcontents

I have used the following Linux distributions: \textsc{Ubuntu, Kubuntu, SUSE, OpenSUSE}, where the 1st one is install in my personal notebooks\texttt{/}laptops, the 2nd one is install in my WIAS Dell XPS 15 (KDE provides a lot of good stuffs), while the other ones are install in computer servers at WIAS Berlin. Note that SUSE \& \textsc{OpenSUSE} are produced by Germans\footnote{In my own experiences, I believe that Germans \& Frenches prefer building their own facilities over using those provided by the rest of the world.}.

\begin{question}
	Which resources I should use to learn deeply Linux in a fast but complete way?
\end{question}
William Shotts. \textit{The Linux Command Line: A Complete Introduction} (2e) seems a good start.

\begin{question}
	Which e-book readers should I use on Linux?
\end{question}

%------------------------------------------------------------------------------%

\chapter{\cite{Shotts2019}. The Linux Command Line: A Complete Introduction. 2e}

\textbf{About the Author.} ``William Shotts has been a software professional for $> 30$ years \& an avid Linux user for $> 20$ years. He has an extensive background in software development, including technical support, quality assurance, \& documentation. He is also the creator of \url{LinuxCommand.org}, a Linux education \& advocacy site featuring news, reviews, \& extensive support for using the Linux command line.'' -- \cite[p. 6]{Shotts2019}.

\noindent\textbf{About the Technical Reviewer.} ``Jordi Guti\'errez Hermoso is a coder, mathematician, \& hacker-errant. He runs Debian GNU\texttt{/}Linux exclusively since 2022, both at home \& at work. Jordi has been involved with GNU Octave, a free numerical computing environment largely compatible with \textsc{Matlab}, \& with Mercurial, a distributed version control system. He enjoys pure \& applied mathematics, skating, swimming, \& knitting. Nowadays he thinks a lot about environmental mapping, greenhouse gas emissions, \& rhino conservation efforts.'' -- \cite[p. 7]{Shotts2019}

%------------------------------------------------------------------------------%

\section*{Introduction}
``I want to tell you a story. No, not the story of how, in 1991, Linus Torvalds wrote the 1st version of the Linux kernel. You can read that story in lots of Linux books. Nor am I going to tell you the story of how, some years earlier, Richard Stallman began the GNU Project to create a free Unix-like operating system. That's an important story too, but most other Linux books have that one, as well.

No, I want to tell you \fbox{the story of how you take back control of your computer}.

When I began working with computers as a college student in the late 1970s, there was a revolution going on. The invention of the microprocessor\footnote{\textbf{microprocessor} [n] (\textit{computing}) a small unit of a computer that contains all the functions of the central processing unit.} had made it possible for ordinary people like you \& me to actually own a computer. It's hard for many people today to imagine what the world was like when only big business \& big government ran all the computers. Let's just say, you couldn't get much done.

Today, the world is very different. Computers are everywhere, from tiny wristwatches to giant data centers to everything in between. In addition to ubiquitous\footnote{\textbf{ubiquitous} [a] present, appearing or found everywhere.} computers, we also have a ubiquitous network connecting them together. This has created a wondrous\footnote{\textbf{wondrous} [a] (\textit{literary}) strange, beautiful, \& impressive, \textsc{synonym}: \textbf{wonderful}.} new age of personal empowerment\footnote{\textbf{empowerment} [n] [uncountable] a positive feeling that you have some control over your life or the situation you are in.} \& \fbox{creative freedom}, but over the last couple of decades something else has been happening. A few giant corporations have been imposing their control over most of the world's computers \& deciding what you can \& cannot do with them. Fortunately, people from all over the world are doing something about it. They are fighting to maintain control of their computers by writing their own software. They are building Linux.

Many people speak of ``freedom'' with regard to Linux, but I don't think most people know what this freedom really means. Freedom is the power to decide what your computer does, \& the only way to have this freedom is to know what your computer is doing. Freedom is a computer that is without secrets, one where everything can be known if you care enough to find out.'' -- \cite[pp. 30--31]{Shotts2019}

\subsection*{Why Use the Command Line?}
``Have you ever noticed in the movies when the ``superhacker'' -- you know, the guy who can break into the ultra-secure military computer in $< 30$ seconds -- sits down at the computer, he never touches a mouse? It's because filmmakers realize that we, as human beings, instinctively know the only way to really get anything done on a computer is by typing on a keyboard!

Most computer users today are familiar only with the \textit{graphical user interface} (GUI) \& have been taught by vendors\footnote{\textbf{vendor} [n] \textbf{1.} a person or company that sells things, especially outside on the street; \textbf{2.} (\textit{formal}) a company that sells a particular product; \textbf{3.} (\textit{law}) a person who is selling something, especially a house.} \& pundits\footnote{\textbf{pandit} [n] (also \textbf{pundit}) \textbf{1.} a Hindu priest or wise man; \textbf{2.} (\textit{Indian English}) a teacher; \textbf{3.} (\textit{Indian English}) a musician with a lot of skill.} that the \textit{command line interface} (\textit{CLI}) is a terrifying thing of the past. This is unfortunate because a good command line interface is a marvelously\footnote{\textbf{marvellously} [adv] (US English \textbf{marvelously}) very; very well, \textsc{synonym}: \textbf{wonderfully}.} expressive way of communicating with a computer in much the same way the written word is for human beings. It's been said that ``graphical user interfaces make easy tasks easy, while command line interfaces make difficult tasks possible,'' \& this is still very true today.

Since Linux is modeled after the Unix family of operating systems, it shares the same rich heritage of command line tools as Unix. Unix came into prominence\footnote{\textbf{prominence} [n] \textbf{1.} [uncountable, singular] the state of being important, well known or easy to notice; \textbf{2.} [countable, uncountable] (\textit{medical} or \textit{formal}) a thing that sticks out from something; the fact or state of sticking out from something.} during the early 1980s (although it was 1st developed a decade earlier), before the widespread adoption of the graphical user interface \&, as a result, developed an extensive command line interface instead. In fact, 1 of the strongest reasons early adopters of Linux chose it over, say, Windows NT was the powerful command line interface that made the ``difficult tasks possible.'' -- \cite[p. 31]{Shotts2019}

\subsection*{What This Book Is About}
``This book is a broad overview of ``living'' on the Linux command line. Unlike some books that concentrate on just a single program, such as the shell program \texttt{bash}, this book will try to convey how to get along with the command line interface in a larger sense. How does it all work? What can it do? What's the best way to use it?

\textbf{This is not a book about Linux system administration.} While any serious discussion of the command line will invariably lead to system administration topics, this book touches on only a few administration issues. It will, however, prepare the reader for additional study by providing a solid foundation in the use of the command line, an essential tool for any serious system administration task.

\textbf{This book is Linux-centric.} Many other books try to broaden their appeal by including other platforms such as generic Unix \& macOS. In doing so, they ``water down'' their content to feature only general topics. This book, on the other hand, covers only contemporary Linux distributions. 95\% of the content is useful for users of other Unix-like systems, but this book is highly targeted at the modern Linux command line user.'' -- \cite[p. 32]{Shotts2019}

\subsection*{Who Should Read This Book}
``This book is for new Linux users who have migrated from other platforms. Most likely you are a ``power user'' of some version of Microsoft Windows. Perhaps your boss has told you to administer a Linux server, or you're entering the exciting new world of single board computers (SBC) such as the Raspberry Pi. You may just be a desktop user who is tired of all the security problems \& wants too give Linux a try. That's fine. All are welcome here.

That being said, there is no shortcut to Linux enlightenment. \fbox{Learning the command line is challenging \& takes real effort.} It's not that it's so hard, but rather it's so \textit{vast}. The average Linux system has literally \textit{thousands} of programs you can employ on the command line. Consider yourself warned; learning the command line is not a casual\footnote{\textbf{casual} [a] \textbf{1.} [usually before noun] without paying attention to detail; \textbf{2.} [usually before noun] not showing much care or thought; \textbf{3.} [usually before noun] (of a relationship) lasting only a short time \& without deep affection; \textbf{4.} [usually before noun] (BE) (of work) not permanent; not regular; \textbf{5.} not formal; \textbf{6.} [only before noun] happening by chance; doing something by chance.} endeavor\footnote{\textbf{endeavour} [n] (US \textbf{endeavor}) (\textit{formal}) \textbf{1.} [uncountable, countable] serious effort to achieve something; an attempt to do something, especially something new or difficult; \textbf{2.} [countable, usually plural] something that somebody does; [v] \textbf{endeavor to do something} (\textit{formal}) to try hard to do or achieve something, \textsc{synonym}: \textbf{strive}.}.

On the other hand, learning the Linux command line is extremely rewarding. If you think you're a ``power user'' now, just wait. You don't know what real power is -- yet. \&, unlike many other computer skills, knowledge of the command line is long-lasting. The skills learned today will still be useful 10 years from now. \fbox{The command line has survived the test of time.}

It is also assumed that you have no programming experience, but don't worry, we'll start you down that path as well.'' -- \cite[pp. 32--33]{Shotts2019}

\subsection*{What's in This Book}
``This material is presented in a carefully chosen sequence, muck like a tutor sitting next to you guiding you along. Many authors treat this material in a ``systematic'' fashion, exhaustively\footnote{\textbf{exhaustive} [a] including everything possible; very thorough or complete.} covering each topic in order. This makes sense from a writer's perspective but can be very confusing to new users.

Another goal is to acquaint\footnote{\textbf{acquaint} [v] (\textit{formal}) \textbf{acquaint somebody\texttt{/}yourself with something} to make somebody\texttt{/}yourself familiar with or aware of something.} you with the Unix way of thinking, which is different from the Windows way of thinking. Along the way, we'll go on a few side trips to help you understand why certain things work the way they do \& how they got that way. Linux is not just a piece of software; it's also a small part of the larger Unix culture, which has its own language \& history. I might throw in a rant or 2, as well.

This book is divided into 4 parts, each covering some aspect of the command line experience.
\begin{itemize}
	\item \textbf{Part 1, ``Learning the Shell,''} starts our exploration of the basic language of the command line including such things as the structure of commands, file system navigation, command line editing, \& finding help \& documentation for commands.
	\item \textbf{Part 2, ``Configuration \& the Environment,''} covers editing configuration files that control the computer's operation from the command line.
	\item \textbf{Part 3, ``Common Tasks \& Essential Tools,''} explores many of the ordinary tasks that are commonly performed from the command line. Unix-like operating systems, such as Linux, contain many ``classic'' command line programs that are used to perform powerful operations on data.
	\item \textbf{Part 4, ``Writing Shell Scripts,''} introduces shell programming, an admittedly rudimentary but easy-to-learn technique for automating many common computing tasks. By learning shell programming, you will become familiar with concepts that can be applied to many other programming languages.'' -- \cite[pp. 33--34]{Shotts2019}
\end{itemize}

\subsection*{How to Read This Book}
``Start at the beginning of the book \& follow it to the end. It isn't written as a reference work; it's really more like a story with a beginning, middle, \& end.'' -- \cite[p. 34]{Shotts2019}

\subsection*{Prerequisites}
``To use this book, all you will need is a working Linux installation. You can get this in 1 of 2 ways:
\begin{itemize}
	\item \textbf{Install Linux on a (not so new) computer.} It doesn't matter which distribution you choose, though most people today start out with either Ubuntu, Fedora, or OpenSUSE. If in doubt, try Ubuntu 1st. Installing a modern Linux distribution can be ridiculously easy or ridiculously difficult depending on your hardware. I suggest a desktop computer that is a couple of years gold \& has at least 2GB of RAM \& 6GB of free hard disk space. Avoid laptops \& wireless networks if at all possible, as these are often more difficult to get working.
	\item \textbf{Use a ``live CD'' or USB flash drive.} 1 of the cool things you can do with many Linux distributions is run them directly from a CD-ROM or USB flash drive without installing them at all. Just go into your BIOS setup \& set your computer to boot from a CD-ROM drive or USB device \& reboot. Using this method is a great way to test a computer for Linux compatibility prior to installation. The disadvantage is that it may be slow compared to having Linux installed on your hard drive. Both Ubuntu \& Fedora (among others) have live versions.
\end{itemize}
Regardless of how you install Linux, you'll need to have occasional superuser (i.e., administrative) privileges to carry out the lessons in this book.

After you have a working installation, start reading \& follow along with your own computer. Most of the material in this book is ``hands on,'' so sit down \& get typing!

\textbf{Why I don't call it ``GNU\texttt{/}LINUX''.} In some quarters, it's politically correct to call the Linux operating system the ``GNU\texttt{/}Linux operating system.'' The problem with ``Linux'' is that there is no completely correct way to name it because it was written by many different people in a vast, distributed development effort. Technically speaking, Linux is the name of the operating system's kernel, nothing more. The kernel is very important, of course, since it makes the operating system go, but it's not enough to form a complete operating system.

Enter Richard Stallman, the genius-philosopher who founded the Free Software movement, started the Free Software Foundation, formed the GNU Project, wrote the 1st version of the GNU C Compiler (\texttt{gcc}), created the GNU General Public License (the GPL), etc., etc., etc. He \textit{insists} that you call it ``GNU\texttt{/}Linux'' to properly reflect the contributions of the GNU Project. While the GNU Project predates the Linux kernel \& the project's contributions are extremely deserving of recognition, placing them in the name is unfair to everyone else who made significant contributions. Besides, I think ``Linux\texttt{/}GNU'' would be more technically accurate since the kernel boots 1st \& everything else runs on top of it.

In popular usage, Linux refers to the kernel \& all the other free \& open source software found in the typical Linux distribution, i.e., the entire Linux ecosystem, not just the GNU components. The operating system marketplace seems to prefer 1-word names such as DOS, Windows, macOS, Solaris, Irix, \& AIX. I have chosen to use the popular format. If, however, you prefer to use ``GNU\texttt{/}Linux'' instead, perform a mental search-\&-replace while reading this book. I won't mind.'' -- \cite[pp. 34--36]{Shotts2019}

\subsection*{What's New in the 2nd Edition}
``While the basic structure \& content remain the same, this edition of \textit{The Linux Command Line} is peppered with various refinements, classifications, \& modernizations, many of which are based on reader feedback. In addition, 2 particular improvements stand out. 1st, the book now assumes \texttt{bash} version $4.x$,  which was not in wide use at the time of the original manuscript. This 4th major version of \texttt{bash} added several useful new features now covered in this edition. 2nd, Part 4, ``Shell Scripting,'' has been improved to provide better examples of good scripting practice. The scripts included in Part 4 have been revised to make them more robust, \& I also fixed a few bugs.'' ``This book is an ongoing project, like many open source software projects.'' -- \cite[p. 36]{Shotts2019}

%------------------------------------------------------------------------------%

\begin{center}
	\huge Part I: Learning The Shell
\end{center}

%------------------------------------------------------------------------------%

\section{What Is the Shell?}
``When we speak of the command line, we are really referring to the \textit{shell}. The shell is a program that takes keyboard commands \& passes them to the operating system to carry out. Almost all Linux distributions supply a shell program from the GNU Project called \texttt{bash}. The name is acronym for \textit{b}ourne-\textit{a}gain \textit{sh}ell, a reference to the fact that \texttt{bash} is an enhanced replacement for \texttt{sh}, the original Unix shell program written by Steve Bourne.'' -- \cite[p. 38]{Shotts2019}

\subsection{Terminal Emulators}
``When using a graphical user interface (GUI), we need another program called a \textit{terminal emulator} to interact with the shell. If we look through our desktop menus, we will probably find one. KDE uses konsole, \& GNOME uses gnome-terminal, though it's likely called simply Terminal on your menu. A number of other terminal emulators are available for Linux, but they all basically do the same thing: give us access to the shell. You will probably develop a preference for 1 or another terminal emulator based on the number of bells \& whistles it has.'' -- \cite[p. 38]{Shotts2019}

\subsection{Making Your 1st Keystrokes}
``Launch the terminal emulator. Once it comes up, we should see something like this: \verb|[me@linuxbox ~]$|. This is called a \textit{shell prompt}, \& it will appear whenever the shell is ready to accept input. While it might vary in appearance somewhat depending on the distribution, it will typically include your \texttt{username@machinename}, followed by the current working directory (more about that in a little bit) \& a dollar sign.

If the last character of the prompt is a hash mark \texttt{\#} rather than a dollar sign, the terminal session has superuser privileges. This means either we are logged in as the root user or we selected a terminal emulator that provides superuser (administrative) privileges.'' -- \cite[p. 39]{Shotts2019}

\subsubsection{Command History}
``If we press the up arrow, we will see that the previous command entered reappears after the prompt. This is called \textit{command history}. Most Linux distributions remember the last $1,000$ commands by default. Press the down arrow \& the previous command disappears.'' -- \cite[p. 39]{Shotts2019}

\subsubsection{Cursor Movement}
``Recall the previous command by pressing the up arrow again. If we try the left \& right arrows, we'll see that we can position the cursor anywhere on the command line. This makes editing commands easy.

\textbf{A few words about mice \& focus.} While the shell is all about the keyboard, you can also use a mouse with your terminal emulator. A mechanism built into the X Window System (the underlying engine that makes the GUI go) supports a quick copy-\&-paste technique. If you highlight some text by holding down the left mouse button \& dragging the mouse over it (or double-clicking a word), it is copied into a buffer maintained by X. Pressing the middle mouse button will cause the text to be pasted at the cursor location. Try it.

Don't be tempted to use \textsc{ctrl-C} \& \textsc{ctrl-V} to perform copy \& paste inside a terminal window. They don't work. These control codes have different meanings to the shell \& were assigned many years before the release of Microsoft Windows.

Your graphical desktop environment (most likely KDE or GNOME), in an effort to behave like Windows, probably has its focus policy set to ``click to focus.'' This means for a window to get focus (become active), you need to click on it. This is contrary to the traditional X behavior of ``focus follows mouse,'' which means that a window gets focus just by passing the mouse over it. The window will not come to the foreground until you click on it, but it will be able to receive input. Setting the focus policy to ``focus follows mouse'' will make the copy-\&-paste technique even more useful. Give it a try if you can (some desktop environments such as Ubuntu's Unity no longer support it). I think if you give it a chance, you will prefer it. You will find this setting in the configuration program for your window manager.'' -- \cite[p. 40]{Shotts2019}

\subsection{Try Some Simple Commands}
``Now that we have learned to enter text in the terminal emulator, let's try a few simple commands. Let's begin with the \texttt{date} command, which displays the current time \& date.
\begin{verbatim}
	[me@linuxbox ~]$ date
	Fri Feb 2 15:09:41 EST 2018
\end{verbatim}
A related command is \texttt{cal}, which, by default, displays a calendar of the current month.
\begin{verbatim}
	[me@linuxbox ~]$ cal
	February 2018
	Su Mo Tu We Th Fr Sa
	             1  2  3
	 4  5  6  7  8  9 10
	11 12 13 14 15 16 17
	18 19 20 21 22 23 24
	25 26 27 28
\end{verbatim}
\textbf{The console behind the curtain.} Even if we have no terminal emulator running, several terminal sessions continue to run behind the graphical desktop. We can access these sessions, called \textit{virtual consoles}, by pressing \textsc{ctrl-alt-F1} through \textsc{ctrl-alt-F6}  on most Linux distributions. When a session is accessed, it presents a login prompt into which we can enter our username \& password. To switch from 1 virtual console to another, press \texttt{alt-F1} through \textsc{alt-F6}. On most systems, we can return to the graphical desktop by pressing \texttt{alt-F7}.

To see the current amount of free space on our disk drives, enter \texttt{df}.
\begin{verbatim}
	[me@linuxbox ~]$ df
	tmpfs             783256     2288    780968   1% /run
	/dev/nvme0n1p2 491039648 79254728 386768040  18% /
	tmpfs            3916268   154944   3761324   4% /dev/shm
	tmpfs               5120        4      5116   1% /run/lock
	/dev/nvme0n1p1     94759     5329     89430   6% /boot/efi
	tmpfs             783252      156    783096   1% /run/user/1000
\end{verbatim}
Likewise, to display the amount of free memory, enter the \texttt{free} command.'' -- \cite[pp. 41--42]{Shotts2019}
\begin{verbatim}
	[me@linuxbox ~]$ free
	               total        used        free      shared  buff/cache   available
	Mem:         7832540     6709784      217512      327756      905244      502532
	Swap:              0           0           0
\end{verbatim}

\subsection{Ending a Terminal Session}
``We can end a terminal session by closing the terminal emulator window, by entering the \texttt{exit} command at the shell prompt, or by pressing \texttt{ctrl-D}. \verb|[me@linuxbox ~]$ exit|.'' -- \cite[p. 42]{Shotts2019}

%------------------------------------------------------------------------------%

\section{Navigation}
``The 1st thing we need to learn (besides how to type) is how to navigate the file system on our Linux system. In this chapter, we will introduce the following commands: \texttt{pwd}: print name of current working directory, \texttt{cd}: change directory, \texttt{ls}: list directory contents.'' -- \cite[p. 43]{Shotts2019}

\subsection{Understanding the File System Tree}
``Like Windows, a Unix-like operating system such as Linux organizes its files in what is called a \textit{hierarchical directory structure}. This means they are organized in a tree-like pattern of directories (sometimes called \textit{folders} in other systems), which may contain files \& other directories. The 1st directory in the file system is called the \textit{root directory}. The root directory contains files \& subdirectories, which contain more files \& subdirectories, \& so on.

Note that unlike Windows, which has a separate file system tree for each storage device, Unix-like systems such as Linux always have a single file system tree, regardless of how many drives or storage devices are attached to the computer. Storage devices are attached (or more correctly, \textit{mounted}) at various points on the tree according to the whims of the \textit{system administrator}, the person (or people) responsible for the maintenance of the system.'' -- \cite[pp. 43--44]{Shotts2019}

\subsection{The Current Working Directory}
``Most of us are probably familiar with a graphical file manager that represents the file system tree. Notice that the tree is usually shown upended, i.e., with the root at the top \& the various branches descending below.

However, the command line has no pictures, so to navigate the file system tree, we need to think of it in a different way.

Imagine that the file system is a maze shaped like an upside-down tree \& we are able to stand in the middle of it. At any given time, we are inside a single directory, \& we can see the files contained in the directory \& the pathway to the directory above us (called the \textit{parent directory}) \& any subdirectories below us. The directory we are standing in is called the \textit{current working directory}. To display the current working directory, we use the \texttt{pwd} (print working directory) command.
\begin{verbatim}
	[me@linuxbox ~]$ pwd
	/home/me
\end{verbatim}
When we 1st log in to our system (or start a terminal emulator session), our current working directory is set to our \textit{home directory}. Each user account is given its own home directory, \& it is the only place a regular user is allowed to write files.'' -- \cite[pp. 44--45]{Shotts2019}

\subsection{Listing the Contents of a Directory}
``To list the files \& directories in the current working directory, we use the \texttt{ls} command.
\begin{verbatim}
	[me@linuxbox ~]$ ls
	Desktop Documents Music Pictures Public Templates Videos
\end{verbatim}
Actually, we can use the \texttt{ls} command to list the contents of any directory, not just the current working directory, \& there are many other fun things it can do as well. We'll spend more time with \texttt{ls} in Chap. 3.'' -- \cite[p. 45]{Shotts2019}

\subsection{Changing the Current Working Directory}
``To change our working directory (where we are standing in the tree-shaped maze), we use the \texttt{cd} command. To do this, type \texttt{cd} followed by the pathname of the desired working directory. A pathname is the route we take along the branches of the tree to get to the directory we want. We can specify pathnames in 1 of 2 different ways: as \textit{absolute pathnames} or as \textit{relative pathnames}. Let's deal with absolute pathnames 1st.'' -- \cite[p. 45]{Shotts2019}

\subsubsection{Absolute Pathnames}
``An absolute pathname beings with the root directory \& follows the tree branch by branch until the path to the desired directory or file is completed. E.g., there is a directory on your system in which most of the system's programs are installed. The directory's pathname is \texttt{/usr/bin}. I.e., from the root directory (represented by the leading slash in the pathname) there is a directory called \texttt{usr} that contains a directory called \texttt{bin}.
\begin{verbatim}
	[me@linuxbox ~]$ cd /usr/bin
	[me@linuxbox bin]$ pwd
	/usr/bin
	[me@linuxbox bin]$ ls
	...Listing of many, many files ...
\end{verbatim}
Now we can see that we have changed the current working directory to \texttt{/usr/bin} \& that it is full of files. Notice how the shell prompt has changed? As a convenience, it is usually set up to automatically display the name of the working directory.'' -- \cite[p. 46]{Shotts2019}

\subsubsection{Relative Pathnames}
``Where an absolute pathname starts from the root directory \& leads to its destination, a relative pathname starts from the working directory. To do this, it uses a couple of special notations to represent relative positions in the file system tree. These special notations are \texttt{.} (dot) \& \texttt{..} (dot dot).

The \texttt{.} notation refers to the working directory, \& the \texttt{..} notation refers to the working directory's parent directory. Here is how it works. Let's change the working directory to \texttt{/usr/bin} again.
\begin{verbatim}
	[me@linuxbox ~]$ cd /usr/bin
	[me@linuxbox bin]$ pwd
	/usr/bin
\end{verbatim}
Now let's say that we wanted to change the working directory to the parent of \texttt{/usr/bin}, which is \texttt{/usr}. We could do that 2 different ways, either with an absolute pathname:
\begin{verbatim}
	[me@linuxbox bin]$ cd /usr
	[me@linuxbox usr]$ pwd
	/usr
\end{verbatim}
or with a relative pathname:
\begin{verbatim}
	[me@linuxbox bin]$ cd ..
	[me@linuxbox usr]$ pwd
	/usr
\end{verbatim}
2 different methods with identical results. Which one should use? \footnote{The one that requires the least typing!}

Likewise, we can change the working directory from \texttt{/usr} to \texttt{/usr/bin} in 2 different ways, either using an absolute pathname:
\begin{verbatim}
	[me@linuxbox usr]$ cd /usr/bin
	[me@linuxbox bin]$ pwd
	/usr/bin
\end{verbatim}
or using a relative pathname:
\begin{verbatim}
	[me@linuxbox usr]$ cd ./bin
	[me@linuxbox bin]$ pwd
	/usr/bin
\end{verbatim}
Now, there is something important to point out here. In almost all cases, we can omit the \texttt{./} part because it is implied. Typing the following does the same thing:
\begin{verbatim}
	[me@linuxbox usr]$ cd bin
\end{verbatim}
In general, if we do not specify a pathname to something, the working directory will be assumed.

\textbf{Important facts about filenames.} On Linux systems, files are named in a manner similar to that of other systems such as Windows, but there are some important differences.
\begin{itemize}
	\item Filenames that begin with a period character are hidden. This only means that \texttt{ls} will not list them unless you say \texttt{ls -a}. When you account was created, several hidden files were placed in your home directory to configure things for your account. In Chap. 11 we will take a closer look at some of these files to see how you can customize your environment. In addition, some applications place their configuration \& setting files in your home directory as hidden files.
	\item Filenames \& commands in Linux, like Unix, are case sensitive. The filenames \texttt{File1} \& \texttt{file1} refer to different files.
	\item Though Linux supports long filenames that may contain embedded spaces \& punctuation characters, limit the punctuation characters in the names of files you create to period, dash, \& underscore. \textit{Most important, do not embed spaces in filenames}. If you want to represent spaces between words in a filename, use underscore characters. You will thank yourself later.
	\item Linux has no concept of a ``file extension'' like some other operating systems. You may name files any way you like. The contents or purpose of a file is determined by other means. Although Unix-like operating systems don't use file extensions to determine the contents\texttt{/}purpose of files, many application programs do.'' -- \cite[pp. 46--48]{Shotts2019}
\end{itemize}

\subsubsection{Some Helpful Shortcuts}
Some useful ways to quickly change the current working directory. \textsc{cd} Shortcuts:
\begin{enumerate*}
	\item[$\bullet$] \texttt{cd}: Changes the working directory to your home directory.
	\item[$\bullet$] \texttt{cd -}: Changes the working directory to the previous working directory.
	\item[$\bullet$] \verb|cd ~user_name|: Changes the working directory to the home directory of \verb|user_name|.
\end{enumerate*}

%------------------------------------------------------------------------------%

\section{Exploring the System}
``Now that we know how to move around the file system, it's time for a guided tour of our Linux system. Before we start, however, we're going to learn some more commands that will be useful along the way.
\begin{enumerate*}
	\item[$\bullet$] \texttt{ls}: List directory contents.
	\item[$\bullet$] \texttt{file}: Determine file type.
	\item[$\bullet$] \texttt{less}: View file contents.'' -- \cite[p. 50]{Shotts2019}
\end{enumerate*}

\subsection{More Fun with \texttt{ls}}
``The \texttt{ls} command is probably the most used command, \& for good reason. With it, we can see directory contents \& determine a variety of important file \& directory attributes. As we have seen, we can simply enter \texttt{ls} to get a list of files \& subdirectories contained in the current working directory.
\begin{verbatim}
	[me@linuxbox ~]$ ls
	Desktop Documents Music Pictures Public Templates Videos
\end{verbatim}
Besides the current working directory, we can specify the directory to list, like so:
\begin{verbatim}
	me@linuxbox ~]$ ls /usr
	bin games include lib local sbin share src
\end{verbatim}
We can even specify multiple directories. In the following example, we list both the user's home directory (symbolized by the \verb|~| character) \& the \texttt{/usr} directory:
\begin{verbatim}
	[me@linuxbox ~]$ ls ~ /usr
	/home/me:
	Desktop Documents Music Pictures Public Templates Videos
	/usr:
	bin games include lib local sbin share src
\end{verbatim}
We can also change the format of the output to reveal more detail.
\begin{verbatim}
	[me@linuxbox ~]$ ls -l
	total 56
	drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Desktop
	drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Documents
	drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Music
	drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Pictures
	drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Public
	drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Templates
	drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Videos
\end{verbatim}
By adding \texttt{-l} to the command, we changed the output to the long format.'' -- \cite[pp. 50--51]{Shotts2019}

\subsubsection{Options \& Arguments}
``This brings us to a very important point about how most commands work. Commands are often followed by 1 or more \textit{options} that modify their behavior \&, further, by 1 or more \textit{arguments}, the items upon which the command acts. So, most commands look kind of like this: \texttt{\textbf{command} -options arguments}. Most commands use options, which consist of a single character preceded by a dash, e.g., \texttt{-l}. Many commands, however, including those from the GNU Project, also support \textit{long options}, consisting of a word preceded by 2 dashes. Also, many commands allow multiple short options to be strung together. In the following example, the \texttt{ls} command is given 2 options, which are the \texttt{l} option to produce long format output, \& the \texttt{t} option to sort the result by the file's modification time.
\begin{verbatim}
	[me@linuxbox ~]$ ls -lt
\end{verbatim}
We'll add the long option \texttt{--reverse} to reverse the order of the sort.
\begin{verbatim}
	[me@linuxbox ~]$ ls -lt --reverse
\end{verbatim}

\begin{remark}
	Command options, like filenames in Linux, are case sensitive.
\end{remark}
The \texttt{ls} command has a large number of possible options, the most common of which are listed in \textsf{Table 3.1. Common \texttt{ls} Options. Option : Long option : Description.}
\begin{itemize}
	\item \texttt{-a}: \texttt{--all}: List all files, even those with names that begin with a period, which are normally not listed (i.e., hidden).
	\item \texttt{-A}: \texttt{--almost-all}: Like the \texttt{-a} option except it does not list. (current directory) \& \texttt{..} (parent directory).
	\item \texttt{-d}: \texttt{--directory}: Ordinarily, if a directory is specified, \texttt{ls} will list the contents of the directory, not the directory itself. Use this option in conjunction with the \texttt{-l} option to see details about the directory rather than its contents.
	\item \texttt{-F}: \texttt{--classify}: This option will append an indicator character to the end of each listed name. E.g., it will append a forward slash \texttt{/} if the name is a directory.
	\item \texttt{-h}: \texttt{--human-readable}: In long format listings, display file sizes in human-readable format rather than in bytes.
	\item \texttt{-l}: Display results in long format.
	\item \texttt{-r}: \texttt{--reverse}: Display the results in reverse order. Normally, \texttt{ls} displays its results in ascending alphabetical order.
	\item \texttt{-s}: Sort results by file size.
	\item \texttt{-t}: Sort by modification in time.'' -- \cite[pp. 51--53]{Shotts2019}
\end{itemize}

\subsubsection{A Longer Look at Long Format}
As we aw earlier, the \texttt{-l} option causes \texttt{ls} to display its results in long format. This format contains a great deal of useful information. Here is the \texttt{Examples} directory from an Ubuntu system:
\begin{verbatim}
	-rw-r--r-- 1 root root 3576296 2017-04-03 11:05 Experience ubuntu.ogg
	-rw-r--r-- 1 root root 1186219 2017-04-03 11:05 kubuntu-leaflet.png
	-rw-r--r-- 1 root root 47584 2017-04-03 11:05 logo-Edubuntu.png
	-rw-r--r-- 1 root root 44355 2017-04-03 11:05 logo-Kubuntu.png
	-rw-r--r-- 1 root root 34391 2017-04-03 11:05 logo-Ubuntu.png
	-rw-r--r-- 1 root root 32059 2017-04-03 11:05 oo-cd-cover.odf
	-rw-r--r-- 1 root root 159744 2017-04-03 11:05 oo-derivatives.doc
	-rw-r--r-- 1 root root 27837 2017-04-03 11:05 oo-maxwell.odt
	-rw-r--r-- 1 root root 98816 2017-04-03 11:05 oo-trig.xls
	-rw-r--r-- 1 root root 453764 2017-04-03 11:05 oo-welcome.odt
	-rw-r--r-- 1 root root 358374 2017-04-03 11:05 ubuntu Sax.ogg
\end{verbatim}
Table 3-2 provides us with a look at the different fields from 1 of the files \& their meanings. \textsf{Table 3-2: \texttt{ls} Long Listing Fields. Field : Meaning.}
\begin{itemize}
	\item \verb|-rw-r--r--|: Access rights to the file. The 1st character indicates the type of file. Among the different types, a leading dash means a regular file, while a \texttt{d} indicates a directory. The next 3 characters are the access rights for the file's owner, the next 3 are for members of the file's group, \& the final 3 are for everyone else.
	\item \texttt{1}: File's number of hard links.
	\item \texttt{root}: The username of the file's owner.
	\item \texttt{root}: The name of the group that owns the file.
	\item \texttt{32059}: Size of the file in bytes.
	\item \texttt{2017-04-03 11:05}: Date \& time of the file's last modification.
	\item \texttt{oo-cd-cover.odf}: Name of the file.'' -- \cite[pp. 53--54]{Shotts2019}
\end{itemize}

\subsection{Determining a File's Type with file}
``As we explore the system, it will be useful to know what files contain. To do this, we will use the \texttt{file} command to determine a file's type. As we discussed earlier, filenames in Linux are not required to reflect a file's contents. While a filename like \texttt{picture.jpg} would normally be expected to contain a JPEG-compressed image, it is not required to in Linux. We can invoke the \texttt{file} command this way: \texttt{\textbf{file} filename}. When invoked, the \texttt{file} command will print a brief description of the file's contents. E.g.:
\begin{verbatim}
	[me@linuxbox ~]$ file picture.jpg
	picture.jpg: JPEG image data, JFIF standard 1.01
\end{verbatim}
There are many kinds of files. In fact, 1 of the common ideas in Unix-like operating systems such as Linux is that ``everything is a file.'' As we proceed with our lessons, we will see just how true that statement is.

While many of the files on our system are familiar, e.g., MP3 \& JPEG files, there are many kinds that are a little less obvious \& a few that are quite strange.'' -- \cite[pp. 54--55]{Shotts2019}

\subsection{Viewing File Contents with \texttt{less}}
``The \texttt{less} command is a program to view text files. Throughout our Linux system, there are many files that contain human-readable text. The \texttt{less} program provides a convenient way to examine them.

Why would we want to examine text files? Because many of the files that contain system settings (called \textit{configuration files}) are stored in this format, \& being able to read them gives us insight about how the system works. In addition, some of the actual programs that the system uses (called \textit{scripts}) are stored in this format. In later chapters, we will learn how to edit text files in order to modify system settings \& write our own scripts, but for now we will just took at their contents.

The \texttt{less} command is used like this: \texttt{\textbf{less} filename}.

\textbf{What is ``text''?} There are many ways to represent information on a computer. All methods involve defining a relationship between the information \& some numbers that will be used to represent it. Computers, after all, understand only numbers, \& all data is converted to numeric representation.

Some of these representation systems are very complex (such as compressed video files), while others are rather simple. 1 of the earliest \& simplest is called ASCII text. ASCII (pronounced ``as-key'') is short for American Standard Code for Information Interchange. This is a simple encoding scheme that was 1st used on Teletype machines to map keyboard characters to numbers.

Text is a simple 1-to-1 mapping of characters to numbers. It is very compact. 50 characters of text translates to 50 bytes of data. It is important to understand that text only contains a simple mapping of characters to numbers. It is not the same as a word processor document such as one created by Microsoft Word or LibreOffice Writer. Those files, in contrast to simple ASCII text, contain many non-text elements that are used to describe its structure \& formatting. Plain ASCII text files contain only the characters themselves \& a few rudimentary control codes such as tabs, carriage returns, \& line feeds.

Throughout a Linux system, many files are stored in next format, \& there are many Linux tools that work with text files. Even Windows recognizes the importance of this format. The well-known NOTEPAD.EXE program is an editor for plain ASCII text files.

Once started, the \texttt{less} program allows us to scroll forward \& backward through a text file. E.g., to examine the file that defines all the system's user accounts, enter the following command:
\begin{verbatim}
	[me@linuxbox ~]$ less /etc/passwd
\end{verbatim}
Once the \texttt{less} program starts, we can view the contents of the file. If the file is longer than 1 page, we can scroll up \& down. To exit \texttt{less}, press \texttt{q}. Table 3-3 lists the most common keyboard commands used by \texttt{less}. \textsf{Table 3-3: \texttt{less} Commands. Command : Action}
\begin{itemize}
	\item \textsc{page up} or \texttt{b}: Scroll back 1 page.
	\item \textsc{page down} or space: Scroll forward 1 page.
	\item Up arrow: Scroll up 1 line.
	\item Down arrow: Scroll down 1 line.
	\item \texttt{G}: Move to the end of the text file.
	\item \texttt{1G} or \texttt{g}: Move to the beginning of the text file.
	\item \texttt{/characters}: Search forward to the next occurrence of \texttt{characters}.
	\item \texttt{n}: Search for the next occurrence of the previous search.
	\item \texttt{h}: Display help screen.
	\item \texttt{q}: Quit \texttt{less}.
\end{itemize}
\textbf{Less is more.} The \texttt{less} program was designed as an improved replacement of an earlier Unix program called \textit{more}. The name \textit{less} is a play on the phrase ``less is more'' -- a motto of modernist architects \& designers.

\texttt{less} falls into the class of programs called \textit{papers}, programs that allow the easy viewing of long text documents in a page-by-page manner. Whereas the \texttt{more} program could only page forward, the \texttt{less} program allows paging both forward \& backward \& has many other features as well.'' -- \cite[pp. 55--57]{Shotts2019}

\subsection{Taking a Guided Tour}
``The file system layout on a Linux system is much like that found on other Unix-like systems. The design is actually specified in a published standard called the \textit{Linux Filesystem Hierarchy Standard}. Not all Linux distributions conform to the standard exactly, but most come pretty close.

\textbf{Remember the copy-\&-paste trick!} If you are using a mouse, you can double-click a filename to copy it \& middle-click to paste it into commands.

Next, we are going to wander around the file system ourselves to see what makes our Linux system tick. This will give us a chance to practice our navigation skills. 1 of the things we will discover is that many of the interesting files are in plain human-readable text. As we go about our tour, try the following:
\begin{enumerate*}
	\item[$\bullet$] \texttt{cd} into a given directory.
	\item[$\bullet$] List the directory contents with \texttt{ls -l}.
	\item If you see an interesting file, determine its contents with \texttt{file}.
	\item If it looks like it might be text, try viewing it with \texttt{less}.
\end{enumerate*}
If we accidentally attempt to view a non-text file \& it scrambles the terminal window, we can recover by entering the \texttt{reset} command.

As we wander around, don't be afraid to look at stuff. Regular users are largely prohibited from messing things up. That's the system administrator's job! If a command complains about something, just move on to something else. Spend some time looking around. The system is ours to explore. Remember, \fbox{in Linux, there are no secrets!}

Table 3-4 lists just a few of the directories we can explore. There may be some slight differences depending on our Linux distribution. Don't be afraid to look around \& try more! \textsf{Table 3-4: Directories Found on Linux Systems. Directory : Comments.}
\begin{itemize}
	\item \texttt{/}: The root directory, where everything begins.
	\item \texttt{/bin}: Contains binaries (programs) that must be present for the system to boot \& run.
	\item \texttt{/boot}: Contains the Linux kernel, initial RAM disk image (for drivers needed at boot time), \& the boot loader. Interesting files include \texttt{/boot/grub/grub.conf}, or \texttt{menu.lst}, which is used to configure the boot loader, \& \texttt{/boot/vmlinuz} (or something similar), the Linux kernel.
	\item \texttt{/dev}: This is a special directory that contains \textit{device nodes}. ``Everything is a file'' also applies to devices. Here is where the kernel maintains a list of all the devices it understands.
	\item \texttt{/etc}: The \texttt{/etc} directory contains all the system-wide configuration files. It also contains a collection of shell scripts that start each of the system services at boot time. Everything in this directory should be readable text. While everything in \texttt{/etc} is interesting, here are some all-time favorites: \texttt{/etc/crontab}, a file that defines when automated jobs will run; \texttt{/etc/fstab}, a table of storage devices \& their associated mount points; \& \texttt{/etc/passwd}, a list of the user accounts.
	\item \texttt{/home}: In normal configurations, each user is given a directory in \texttt{/home}. Ordinary users can write files only in their home directories. This limitation protects the system from errant\footnote{\textbf{errant} [a] [only before noun] (\textit{formal or humorous}) \textbf{1.} doing something that is wrong; not behaving in an acceptable way; \textbf{2.} (of a husband or wife) not sexually faithful.} user activity.
	\item \texttt{/lib}: Contains shared library files used by the core system programs. These are similar to dynamic link libraries (DLLs) in Windows.
	\item \texttt{/lost+found}: Each formatted partition or device using a Linux file system, such as \texttt{ext3}, will have this directory. It is used in the case of a partial recovery from a file system corruption event. Unless something really bad has happened to your system, this directory will remain empty.
	\item \texttt{/media}: On modern Linux systems, the \texttt{/media} directory will contain the mount points for removable media such as USB drives, CD-ROMs, \& so on, that are mounted automatically at insertion.
	\item \texttt{/mnt}: On older Linux systems, the \texttt{/mnt} directory contains mount points for removable devices that have been mounted manually.
	\item \texttt{/opt}: The \texttt{/opt} directory is used to install ``optional'' software. This is mainly used to hold commercial software products that might be installed on the system.
	\item \texttt{/proc}: The \texttt{/proc} directory is special. It's not a real file system in the sense of files stored on your hard drive. Rather, it is a virtual file system maintained by the Linux kernel. The ``files'' it contains are peepholes\footnote{\textbf{peephole} [n] a small opening in a wall, door, etc. that you can look through.} into the kernel itself. The files are readable \& will give you a picture of how the kernel sees your computer.
	\item \texttt{/root}: This is the home directory for the root account.
	\item \texttt{/sbin}: This directory contains ``system'' binaries. These are programs that perform vital system tasks that are generally reserved for the superuser.
	\item \texttt{/tmp}: The \texttt{/tmp} directory is intended for the storage of temporary, transient files created by various programs. Some configurations cause this directory to be emptied each time the system is rebooted.
	\item \texttt{/usr}: The \texttt{/usr} directory tree is likely the largest one on a Linux system. It contains all the programs \& support files used by regular users.
	\item \texttt{/usr/bin}; \texttt{/usr/bin} contains the executable programs installed by your Linux distribution. It is not uncommon for this directory to hold thousands of programs.
	\item \texttt{/usr/lib}: The shared libraries for the programs in \texttt{/usr/bin}.
	\item \texttt{/usr/local}: The \texttt{/usr/local} tree is where programs that are not included with your distribution but are intended for system-wide use are installed. Programs compiled from source code are normally installed in \texttt{/usr/local/bin}. On a newly installed Linux system, this tree exists, but it will be empty until the system administrator puts something in it.
	\item \texttt{/usr/sbin}: Contains more system administration programs.
	\item \texttt{/usr/share}: \texttt{/usr/share} contains all the shared data used by programs in \texttt{/usr/bin}. This includes things such as default configuration files, icons, screen backgrounds, sound files, \& so on.
	\item \texttt{/usr/share/doc}: Most packages installed on the system will include some kind of documentation. In \texttt{/usr/share/doc}, we will find documentation files organized by package.
	\item \texttt{/var}: With the exception of \texttt{/tmp} \& \texttt{/home}, the directories we have looked at so far remain relatively static; i.e., their contents don't change. The \texttt{/var} directory tree is where data that is likely to change is stored. Various databases, spool files, user mail, \& so forth, are located here.
	\item \texttt{/var/log}: \texttt{/var/log} contains \textit{log files}, records of various system activity. These are important \& should be monitored from time to time. The most useful ones are \texttt{/var/log/messages} \& \texttt{/var/log/syslog}. Note that for security reasons on some systems, you must be the superuser to view log files.'' -- \cite[pp. 57--61]{Shotts2019}
\end{itemize} 

\subsection{Symbolic Links}
``As we look around, we are likely to see a directory listing (e.g., \texttt{/lib}) with an entry like this:
\begin{verbatim}
	lrwxrwxrwx 1 root root    11 2018-08-11 07:34 libc.so.6 -> libc-2.6.so
\end{verbatim}
Notice how the 1st letter of the listing is \texttt{l} \& the entry seems to have 2 filenames? This is a special kind of a file called a \textit{symbolic link} (also known as a \textit{soft link} or \textit{symlink}). In most Unix-like systems, it is possible to have a file referenced by multiple names. While the value of this might not be obvious, it is really a useful feature.

Picture this scenario: a program requires the use of a shared resource of some kind contained in a file named ``foo,'' but ``foo'' has frequent version changes. It would be good to include the version number in the filename so the administrator or other interested party could see what version of ``foo'' is installed. This presents a problem. If we change the name of the shared resource, we have to track down every program that might use it \& change it to look for a new resource name every time a new version of the resource is installed. That doesn't sound like fun at all.

Here is where symbolic links save the day. Suppose we install version 2.6 of ``foo,'' which has the filename ``foo-2.6,'' \& then create a symbolic link simply called ``foo'' that points to ``foo-2.6.'' This means that when a program opens the file ``foo,'' it is actually opening the file ``foo-2.6.'' Now everybody is happy. The programs that rely on ``foo'' can find it, \& we can still see what actual version is installed. What it is time to upgrade to ``foo-2.7,'' we just add the file to our system, delete the symbolic link ``foo,'' \& create a new one that points to the new version. Not only does this solve the problem of the version upgrade, it also allows us to keep both versions on our machine. Imagine that ``foo-2.7'' has a bug (damn those developers!), \& we need to revert to the old version. Again, we just delete the symbolic link pointing to the new version \& create a new symbolic link pointing to the old version.

The directory listing at the beginning of this section (from the \texttt{/lib} directory of a Fedora system) shows a symbolic link called \texttt{libc.so.6} that points to a shared library file called \texttt{libc-2.6.so}. This means that programs looking for \texttt{libc.so.6} will actually get the file \texttt{libc-2.6.so}.'' -- \cite[pp. 61--63]{Shotts2019}

\subsection{Hard Links}
``While we are on the subject of links, we need to mention that there is a 2nd type of link called \textit{hard links}. Hard links also allow files to have multiple names, but they do it in a different way.'' -- \cite[p. 63]{Shotts2019}

\subsection{Summing Up}
``With our tour behind us, we have learned a lot about our system. We've seen various files \& directories \& their contents. 1 thing you should take away from this is how open the system is. In Linux there are many important files that are plain human-readable text. Unlike many proprietary systems, Linux makes everything available for examination \& study.'' -- \cite[p. 63]{Shotts2019}

%------------------------------------------------------------------------------%

\section{Manipulating Files \& Directories}
``At this point, we are ready for some real work! This chapter will introduce 5 of the most frequently used Linux commands. The following commands are used for manipulating both files \& directories:
\begin{enumerate*}
	\item[$\bullet$] \texttt{cp}: Copy files \& directories.
	\item[$\bullet$] \texttt{mv}: Move\texttt{/}rename files \& directories.
	\item[$\bullet$] \texttt{mkdir}: Create directories.
	\item \texttt{rm}: Remove files \& directories.
	\item[$\bullet$] \texttt{ln}: Create hard \& symbolic links.
\end{enumerate*}

Now, to be frank, some of the tasks performed by these commands are more easily done with a graphical file manager. With a file manager, we can drag \& drop a file from 1 directory to another, cut \& paste files, delete files, \& so on. So why use these old command line programs?

The answer is power \& flexibility. While it is easy to perform simple file manipulations with a graphical file manager, complicated tasks can be easier with the command line programs. E.g., how could we copy all the HTML files from 1 directory to another but copy only files that do not exist in the destination directory or are newer than the versions in the destination directory? It's pretty hard with a file manager but pretty easy with the command line. \verb|cp -u *.html destination|.'' -- \cite[pp. 64--65]{Shotts2019}

\subsection{Wildcards}
``Before we begin using our commands, we need to talk about a shell feature that makes these commands so powerful. Because the shell uses filenames so much, it provides special characters to help you rapidly specify groups of filenames. These special characters are called \textit{wildcards}. Using wildcards (which is also known as \textit{globbing}) allows you to select filenames based on patterns of characters. Table 4-1 lists the wildcards \& what they select. \textsf{Table 4-1: Wildscards. Wildcard : Meaning.}
\begin{itemize}
	\item \texttt{*}: Matches any characters.
	\item \texttt{?}: Matches any single character.
	\item \texttt{[characters]}: Matches any character that is a member of the set \texttt{characters}.
	\item \texttt{[[:class:]]} Matches any character  that is a member of the specified \texttt{class}.
\end{itemize}
Table 4-2 lists the most commonly used character classes. \textsf{Table 4-2: Commonly Used Character Classes. Character class : Meaning}.
\begin{itemize}
	\item \texttt{[:alnum:]}: Matches any alphanumeric character.
	\item \texttt{[:alpha:]}: Matches any alphabetic character.
	\item \texttt{[:digit:]}: Matches any numeral.
	\item \texttt{[:lower:]}: Matches any lowercase letter.
	\item \texttt{[:upper:]}: Matches any uppercase letter.
\end{itemize}
Using wildcards makes it possible to construct sophisticated selection criteria for filenames. Table 4-3 provides some examples of patterns \& what they match. \textsf{Table 4-3: Wildcard Examples. Pattern : Matches.}
\begin{itemize}
	\item \texttt{*}: All files.
	\item \texttt{g*}: Any file beginning with \texttt{g}:
	\item \texttt{b*.txt}: Any file beginning with \texttt{b} followed by any characters \& ending with \texttt{.txt}.
	\item \texttt{Data???}: Any file beginning with \texttt{Data} followed by exactly 3 characters.
	\item \texttt{[abc]*}: Any file beginning with either an \texttt{a}, a \texttt{b}, or a \texttt{c}.
	\item \texttt{BACKUP.[0-9][0-9][0-9]}: Any file beginning with \texttt{BACKUP.} followed by exactly 3 numerals.
	\item \texttt{[[:upper:]]*}: Any file beginning with an uppercase letter.
	\item \texttt{[![:digit:]]*}: Any file not beginning with a numeral.
	\item \texttt{*[[:lower:]123]}: Any file ending with a lowercase letter or the numerals \texttt{1}, \texttt{2}, or \texttt{3}.
\end{itemize}
\textbf{Wildcards work in the GUI, too.} Wildcards are especially valuable not only because they are used so frequently on the command line but because they are also supported by some graphical file managers.
\begin{itemize}
	\item In Nautilus (the file manager for GNOME), you can select files using the Edit $\triangleright$ Select Pattern menu item. Just enter a file selection pattern with wildcards \& the files in the currently viewed directory will be highlighted for selection.
	\item In some versions of Dolphin \& Konqueror (the file managers for KDE), you can enter wildcards directly on the location bar. E.g., if you want to see all the files starting with a lowercase \texttt{u} in the \texttt{/usr/bin} directory, enter \texttt{/usr/bin/u*} in the location bar \& it will display the result.
\end{itemize}
Many ideas originally found in the command line interface make their way into the graphical interface, too. It is 1 of the many things that make the Linux desktop so powerful.

Wildcards can be used with any command that accepts filenames as arguments.

\textbf{Character ranges.} If you coming from another Unix-like environment or have been reading some other books on this subject, you may have encountered the \texttt{[A-Z]} \& \texttt{[a-z]} character range notations. These are traditional Unix notations \& worked in older versions of Linux as well. They can still work, but you have to be careful with them because they will not produce the expected results unless properly configured. For now, you should avoid using them \& use character classes instead.'' -- \cite[pp. 65--67]{Shotts2019}

\subsection{\texttt{mkdir} -- Create Directories}
``The \texttt{mkdir} command is used to create directories. It works like this: \texttt{mkdir directory...}. Note that when 3 periods follow an argument in the description of a command (as in the preceding example), it means that the argument can be repeated. Thus, the following command \texttt{mkdir dir1} would create a single directory named \texttt{dir1}. This command \texttt{mkdir dir1 dir2 dir3} would create 3  directories named \texttt{dir1, dir2}, \& \texttt{dir3}.'' -- \cite[pp. 67--68]{Shotts2019}

\subsection{\texttt{cp} -- Copy Files \& Directories}
``The \texttt{cp} command copies files or directories. It can be used 2 different ways. The following: \texttt{cp item1 item2} copies the single file or directory \texttt{item1} to the file or directory \texttt{item2}. This command: \texttt{cp item... directory} copies multiple items (either files or directories) into a directory.'' -- \cite[p. 68]{Shotts2019}

\subsubsection{Useful Options \& Examples}
``Table 4-4 describes some of the commonly used options (the short option \& the equivalent long option) for \texttt{cp}. \textsf{Table 4-4: \texttt{cp} Options. Option : Meaning.}
\begin{itemize}
	\item \texttt{-a, --archive}: Copy the files \& directories \& all of their attributes, including ownerships \& permissions. Normally, copies take on the default attributes of the user performing the copy. We'll take a look at file permissions in Chap. 9.
	\item \texttt{-i, --interactive}: Before overwriting an existing file, prompt the user for confirmation. If this option is not specified, \texttt{cp} will silently (meaning there will be no warning) overwrite files.
	\item \texttt{-r, --recursive}: Recursively copy directories \& their contents. This option (or the \texttt{-a} option) is required when copying directories.
	\item \texttt{-u, --update}: When copying files from 1 directory to another, only copy files that either don't exist or are newer than the existing corresponding files in the destination directory. This is useful when copying large numbers of files as it skips files that don't need to be copied.
	\item \texttt{-v, --verbose}: Display informative messages as the copy is performed.
\end{itemize}
Table 4-5 provides some examples of these commonly used options. \textsf{Table 4-5: \texttt{cp} Examples: Command. Results.}
\begin{itemize}
	\item \texttt{cp file1 file2}: Copy \texttt{file1} to \texttt{file2}. If \texttt{file2} exists, it is overwritten with the contents of \texttt{file1}. If \texttt{file2} does not exist, it is created.
	\item \texttt{cp -i file1 file2}: Same  as previous command, except that if \texttt{file2} exists, the user is prompted before it is overwritten.
	\item \texttt{cp file1 file2 dir1}: Copy \texttt{file1} \& \texttt{file2} into directory \texttt{dir1}. The directory \texttt{dir1} must already exist.
	\item \texttt{cp dir1/* dir2}: Using a wildcard, copy all the files in \texttt{dir1} into \texttt{dir2}. The directory \texttt{dir2} must already exist.
	\item \texttt{cp -r dir1 dir2}: Copy the contents of directory \texttt{dir1} to directory \texttt{dir2}. If directory \texttt{dir2} does not exist, it is created \&, after the copy, will contain the same contents as directory \texttt{dir1}. If directory \texttt{dir2} does exist, then directory \texttt{dir1} (\& its contents) will be copied into \texttt{dir2}.'' -- \cite[pp. 68--70]{Shotts2019}
\end{itemize}

\subsection{\texttt{mv} -- Move \& Rename Files}
``The \texttt{mv} command performs both file moving \& file renaming, depending on how it is used. In either case, the original filename no longer exists after the operation. \texttt{mv} is used in much the same way as \texttt{cp}, as shown here: \texttt{mv item1 item2} to move or rename the file or directory \texttt{item1} to \texttt{item2}. It's also used as follows: \texttt{mv item... directory} to move 1 or more items from 1 directory to another.'' -- \cite[p. 70]{Shotts2019}

\subsubsection{Useful Options \& Examples}
``\texttt{mv} shares many of the same options as \texttt{cp}, as described in Table 4-6. \textsf{Table 4-6: \texttt{mv} Options. Option : Meaning.}
\begin{itemize}
	\item \texttt{-i, --interactive}: Before overwriting an existing file, prompt the user for confirmation. If this option is not specified, \texttt{mv} will silently overwrite files.
	\item \texttt{-u, --update}: When moving files from 1 directory to another, only move files that either don't exist or are newer than the existing corresponding files in the destination directory.
	\item \texttt{-v, --verbose}: Display informative messages as the move is performed.
\end{itemize}
Table 4-7 provides some examples of using the \texttt{mv} command. \textsf{Table 4-7: \texttt{mv} Examples. Command : Results.}
\begin{itemize}
	\item \texttt{mv file1 file2}: Move \texttt{file1} to \texttt{file2}. If \texttt{file2} exists, it is overwritten with the contents of \texttt{file1}. If \texttt{file2} does not exist, it is created. In either case, \texttt{file1} ceases to exist.
	\item \texttt{mv -i file1 file2}: Same as the previous command, except that if \texttt{file2} exists, the user is prompted before it is overwritten.
	\item \texttt{mv file1 file2 dir1}: Move \texttt{file1} \& \texttt{file2} into directory \texttt{dir1}. The directory \texttt{dir1} must already exist.
	\item \texttt{mv dir1 dir2}: If directory \texttt{dir2} does not exist, create directory \texttt{dir2} \& move the contents of directory \texttt{dir1} into \texttt{dir2} \& delete directory \texttt{dir1}. If directory \texttt{dir2} does exist, move directory \texttt{dir1} (\& its contents) into directory \texttt{dir2}.'' -- \cite[pp. 70--71]{Shotts2019}
\end{itemize}

\subsection{\texttt{rm} -- Remove Files \& Directories}
``The \texttt{rm} command is used to remove (delete) files \& directories, as shown here: \texttt{rm item...} where \texttt{item} is 1 or more files or directories.'' -- \cite[pp. 71--7]{Shotts2019}

\subsubsection{Useful Options \& Examples}
``Table 4-8 describes some of the common options for \texttt{rm}. \textsf{Table 4-8: \texttt{rm} Options. Option : Meaning.}
\begin{itemize}
	\item \texttt{-i, --interactive}: Before deleting an existing file, prompt the user for confirmation. If this option is not specified, \texttt{rm} will silently delete files.
	\item \texttt{-r, --recursive}: Recursively delete directories. This means that if a directory being deleted has subdirectories, delete them too. To delete a directory, this option must be specified.
	\item \texttt{-f, --force}: Ignore nonexistent files \& do not prompt. This overrides the \texttt{--interactive} option.
	\item \texttt{-v, --verbose}: Display information messages as the deletion is performed.
\end{itemize}
\textbf{Be careful with \texttt{rm}!} Unix-like operating systems such as Linux do not have an undelete command. Once you delete something with \texttt{rm}, it's gone. Linux assumes you're smart \& you know what you're doing.

Be particularly careful with wildcards. Consider this classic example. Let's say you want to delete just the HTML files in a directory. To do this, you type the following: \texttt{rm *.html}. This is correct, but if you accidentally place a space between the \texttt{*} \& the \texttt{.html} like so: \texttt{rm * .html} the \texttt{rm} command will delete all the files in the directory \& then complain that there is no file called \texttt{.html}.

Here is a useful tip: whenever you use wildcards with \texttt{rm} (besides carefully checking your typing!), test the wildcard 1st with \texttt{ls}. This will let you see the files that will be deleted. Then press the up arrow to recall the command \& replace \texttt{ls} with \texttt{rm}.

Table 4-9 provides some examples of using the \texttt{rm} command. \textsf{Table 4-9: \texttt{rm} Examples. Command : Results.}
\begin{itemize}
	\item \texttt{rm file1}: Delete \texttt{file1} silently.
	\item \texttt{rm -i file1}: Same as the previous command, except that the user is prompted for confirmation before the deletion is performed.
	\item \texttt{rm -r file1 dir1}: Delete \texttt{file1} \& \texttt{dir1} \& its contents.
	\item \texttt{rm -rf file1 dir1}: Same as the previous command, except that if either \texttt{file1} or \texttt{dir1} does not exist, \texttt{rm} will continue silently.'' -- \cite[pp. 71--73]{Shotts2019}
\end{itemize}

\subsection{\texttt{ln} -- Create Links}
``The \texttt{ln} command is used to create either hard or symbolic links. It is used in 1 of 2 ways. The following creates a hard link: \texttt{ln file link}. The following creates a symbolic link: \texttt{ln -s item link} where \texttt{item} is either a file or a directory.'' -- \cite[p. 73]{Shotts2019}

\subsubsection{Hard Links}
``Hard links are the original Unix way of creating links, compared to symbolic links, which are more modern. By default, every file has a single hard link that gives the file its name. When we create a hard link, we create an additional directory entry for a file. Hard links have 2 important limitations.
\begin{itemize}
	\item A hard link cannot reference a file outside its own file system. This means a link cannot reference a file that is not on the same disk partition as the link itself.
	\item A hard link may not reference a directory.
\end{itemize}
A hard link is indistinguishable from the file itself. Unlike a symbolic link, when you list a directory containing a hard link, you will see no special indication of the link. When a hard link is deleted, the link is removed, but the contents of the file itself continue to exist (i.e., its space is not deallocated) until all links to the file are deleted.

It is important to be aware of hard links because you might encounter them from time to time, but modern practice prefers symbolic links, which we will cover next.'' -- \cite[pp. 73--74]{Shotts2019}

\subsubsection{Symbolic Links}
``Symbolic links were created to overcome the limitations of hard links. They work by creating a special type of file that contains a text pointer to the referenced file or directory. In this regard, they operate in much the same way as a Windows shortcut, though of course they predate the Windows feature by many years.

A file pointed to by a symbolic link \& the symbolic link itself are largely indistinguishable from one another. E.g., if you write something to the symbolic link, the referenced file is written to. When you delete a symbolic link, however, only the \textit{link} is deleted, not the \textit{file} itself. If the file is deleted before the symbolic link, the link will continue to exist but will point to nothing. In this case, the link is said to be \textit{broken}. In many implementations, the \texttt{ls} command will display broken links in a distinguishing color, such as red, to reveal their presence. The concept of links can seem confusing, but hang in there. We're going to try all this stuff, \& it will, ideally, become clear.'' -- \cite[p. 74]{Shotts2019}

\subsection{Building a Playground}
``Because we are going to do some real file manipulation, let's build a safe place to ``play'' with our file manipulation commands. 1st we need a directory to work in. We'll create one in our home directory \& call it \texttt{playground}.'' -- \cite[p. 75]{Shotts2019}

\subsubsection{Creating Directories}
``The \texttt{mkdir} command is used to create a directory. To create our playground directory, we will 1st make sure we are in our home directory \& will then create the new directory.
\begin{verbatim}
	[me@linuxbox ~]$ cd
	[me@linuxbox ~]$ mkdir playground
\end{verbatim}
To make our playground a little more interesting, let's crate a couple of directories inside it called \texttt{dir1} \& \texttt{dir2}. To do this, we will change our current working directory to \texttt{playground} \& execute another \texttt{mkdir}.
\begin{verbatim}
	[me@linuxbox ~]$ cd playground
	[me@linuxbox playground]$ mkdir dir1 dir2
\end{verbatim}
Notice that the \texttt{mkdir} command will accept multiple arguments allowing us to create both directories with a single command.'' -- \cite[p. 75]{Shotts2019}

\subsubsection{Copying Files}
``Next, let's get some data into our playground. We'll do this by copying a file. Using the \texttt{cp} command, we'll copy the \texttt{passwd} file from the \texttt{/etc} directory to the current working directory.
\begin{verbatim}
	[me@linuxbox playground]$ cp /etc/passwd .
\end{verbatim}
Notice how we used shorthand for the current working directory, the single trailing period. So now if we perform an \texttt{ls}, we will see our file.
\begin{verbatim}
	[me@linuxbox playground]$ ls -l
	total 12
	drwxrwxr-x 2 me me 4096 2018-01-10 16:40 dir1
	drwxrwxr-x 2 me me 4096 2018-01-10 16:40 dir2
	-rw-r--r-- 1 me me 1650 2018-01-10 16:07 passwd
\end{verbatim}
Now, just for fun, let's repeat the copy using the \texttt{-v} option (verbose) to see what it does.
\begin{verbatim}
	[me@linuxbox playground]$ cp -v /etc/passwd .
	`/etc/passwd' -> `./passwd'
\end{verbatim}
The \texttt{cp} command performed the copy again but this time displayed a concise message indicating what operation it was performing. Notice that \texttt{cp} overwrote the 1st copy without any warning. Again, this is a case of \texttt{cp} assuming that we know what we're doing. To get a warning, we'll include the \texttt{-i} (interactive) option.
\begin{verbatim}
	[me@linuxbox playground]$ cp -i /etc/passwd .
	cp: overwrite `./passwd'?
\end{verbatim}
Responding to the prompt by entering a \texttt{y} will cause the file to be overwritten; any other character (e.g., \texttt{n}) will cause \texttt{cp} to leave the file alone.'' -- \cite[pp. 75--76]{Shotts2019}

\subsubsection{Moving \& Renaming Files}
``Now, the name \texttt{passwd} doesn't seem very playful \& this is a playground, so let's change it to something else.
\begin{verbatim}
	[me@linuxbox playground]$ mv passwd fun
\end{verbatim}
Let's pass the fun around a little by moving our renamed file to each of the directories \& back again. The following moves it 1st to the directory \texttt{dir1}:
\begin{verbatim}
	[me@linuxbox playground]$ mv fun dir1
\end{verbatim}
The following then moves it from \texttt{dir1} to \texttt{dir2}:
\begin{verbatim}
	[me@linuxbox playground]$ mv dir1/fun dir2
\end{verbatim}
Finally, this command brings it back to the current working directory:
\begin{verbatim}
	[me@linuxbox playground]$ mv dir2/fun .
\end{verbatim}
Next, let's see the effect of \texttt{mv} on directories. 1st we will move our data file into \texttt{dir1} again, like this:
\begin{verbatim}
	[me@linuxbox playground]$ mv fun dir1
\end{verbatim}
Then we move \texttt{dir1} into \texttt{dir2} \& confirm it with \texttt{ls}.
\begin{verbatim}
	[me@linuxbox playground]$ mv dir1 dir2
	[me@linuxbox playground]$ ls -l dir2
	total 4
	drwxrwxr-x 2 me me 4096 2018-01-11 06:06 dir1
	[me@linuxbox playground]$ ls -l dir2/dir1
	total 4
	-rw-r--r-- 1 me me 1650 2018-01-10 16:33 fun
\end{verbatim}
Note that because \texttt{dir2} already existed, \texttt{mv} moved \texttt{dir1} into \texttt{dir2}. If \texttt{dir2} had not existed, \texttt{mv} would have renamed \texttt{dir1} to \texttt{dir2}. Lastly, let's put everything back.
\begin{verbatim}
	[me@linuxbox playground]$ mv dir2/dir1 .
	[me@linuxbox playground]$ mv dir1/fun .
\end{verbatim}
'' -- \cite[pp. 76--77]{Shotts2019}

\subsubsection{Creating Hard Links}
``Now we'll try some links. We'll 1st create some hard links to our data file, like so:
\begin{verbatim}
	[me@linuxbox playground]$ ln fun fun-hard
	[me@linuxbox playground]$ ln fun dir1/fun-hard
	[me@linuxbox playground]$ ln fun dir2/fun-hard
\end{verbatim}
So now we have 4 instances of the file \texttt{fun}. Let's take a look at our playground directory.
\begin{verbatim}
	[me@linuxbox playground]$ ls -l
	total 16
	drwxrwxr-x 2 me me 4096 2018-01-14 16:17 dir1
	drwxrwxr-x 2 me me 4096 2018-01-14 16:17 dir2
	-rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun
	-rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun-hard
\end{verbatim}
1 thing we notice is that both the 2nd fields in the listings for \texttt{fun} \& \texttt{fun-hard} contain a \texttt{4}, which is the number of hard links that now exist for the file. Remember that a file will always have at least 1 link because the file's name is created by a link. So, how do we know that \texttt{fun} \& \texttt{fun-hard} are, in fact, the same file? In this case, \texttt{ls} is not very helpful. While we can see that \texttt{fun} \& \texttt{fun-hard} are both the same size (field \texttt{5}), our listing provides no way to be sure. To solve this problem, we're going to have a dig a little deeper.

When thinking about hard links, it is helpful to imagine that files are made up of 2 parts.
\begin{itemize}
	\item The data part containing the file's contents.
	\item The name part that holds the file's name.
\end{itemize}
When we create hard links, we are actually creating additional name parts that all refer to the same data part. The system assigns a chain of disk blocks to what is called an \textit{inode}, which is then associated with the name part. Each hard link therefore refers to a specific inode containing the file's contents.

The \texttt{ls} command has a way to reveal this information. It is invoked with the \texttt{-i} option.
\begin{verbatim}
	[me@linuxbox playground]$ ls -li
	total 16
	12353539 drwxrwxr-x 2 me me 4096 2018-01-14 16:17 dir1
	12353540 drwxrwxr-x 2 me me 4096 2018-01-14 16:17 dir2
	12353538 -rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun
	12353538 -rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun-hard
\end{verbatim}
In this version of the listing, the 1st field is the inode number \& as we can see, both \texttt{fun} \& \texttt{fun-hard} share the same inode number, which confirms they are the same file.'' -- \cite[pp. 77--78]{Shotts2019}

\subsubsection{Creating Symbolic Links}
``Symbolic links were created to overcome the 2 disadvantages of hard links:
\begin{itemize}
	\item Hard links cannot span physical devices.
	\item Hard links cannot reference directories, only files.
\end{itemize}
Symbolic links are a special type of file that contains a text pointer to the target file or directory. Creating symbolic links is similar to creating hard links.
\begin{verbatim}
	[me@linuxbox playground]$ ln -s fun fun-sym
	[me@linuxbox playground]$ ln -s ../fun dir1/fun-sym
	[me@linuxbox playground]$ ln -s ../fun dir2/fun-sym
\end{verbatim}
The 1st example is pretty straightforward; we simply add the \texttt{-s} option to create a symbolic link rather than a hard link. But what about the next two? Remember that when we create a symbolic link, we are creating a text description of where the target file is relative to the symbolic link. It's easier to see if we look at the \texttt{ls} output, shown here:
\begin{verbatim}
	[me@linuxbox playground]$ ls -l dir1
	total 4
	-rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun-hard
	lrwxrwxrwx 1 me me    6 2018-01-15 15:17 fun-sym -> ../fun
\end{verbatim}
The listing for \texttt{fun-sym} in \texttt{dir1} shows that it is a symbolic link by the leading \texttt{l} in the 1st field \& that it points to \texttt{../fun}, which is correct. Relative to the location of \texttt{fun-sym}, \texttt{fun} is in the directory above it. Notice, too, that the length of the symbolic link file is 6, the number of characters in the string \texttt{../fun} rather than the length of the file to which it is pointing.

When creating symbolic links, you can either use absolute pathnames, as shown here:
\begin{verbatim}
	[me@linuxbox playground]$ ln -s /home/me/playground/fun dir1/fun-sym
\end{verbatim}
or relative pathnames, as we did in our earlier example. In most cases, using relative pathnames is more desirable because it allows a directory tree containing symbolic links \& their referenced files to be renamed \&\texttt{/}or moved without breaking the links.

In addition to regular files, symbolic links can also reference directories.
\begin{verbatim}
	[me@linuxbox playground]$ ln -s dir1 dir1-sym
	[me@linuxbox playground]$ ls -l
	total 16
	drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir1
	lrwxrwxrwx 1 me me    4 2018-01-16 14:45 dir1-sym -> dir1
	drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir2
	-rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun
	-rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun-hard
	lrwxrwxrwx 1 me me    3 2018-01-15 15:15 fun-sym -> fun
\end{verbatim}
Most Linux distributions configure \texttt{ls} to display broken links. The presence of a broken link is not in \& of itself dangerous, but it is rather messy. If we try to use a broken link, we will see this:
\begin{verbatim}
	[me@linuxbox playground]$ less fun-sym
	fun-sym: No such file or directory
\end{verbatim}
Let's clean up a little. We'll delete the symbolic links here:
\begin{verbatim}
	[me@linuxbox playground]$ rm fun-sym dir1-sym
	[me@linuxbox playground]$ ls -l
	total 8
	drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir1
	drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir2
\end{verbatim}
1 thing to remember about symbolic links is that most file operations are carried out on the link's target, not the link itself. \texttt{rm} 
'' -- \cite[pp. 79--80]{Shotts2019}

\subsubsection{Removing Files \& Directories}
``As we covered earlier, the \texttt{rm} command is used to delete files \& directories. We are going to use it to clean up our playground a little bit. 1st, let's delete 1 of our hard links.
\begin{verbatim}
	[me@linuxbox playground]$ rm fun-hard
	[me@linuxbox playground]$ ls -l
	total 12
	drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir1
	lrwxrwxrwx 1 me me    4 2018-01-16 14:45 dir1-sym -> dir1
	drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir2
	-rw-r--r-- 3 me me 1650 2018-01-10 16:33 fun
	lrwxrwxrwx 1 me me    3 2018-01-15 15:15 fun-sym -> fun
\end{verbatim}
That worked as expected. The file \texttt{fun-hard} is gone, \& the link count shown for \texttt{fun} is reduced from 4 to 3, as indicated in the 2nd field of the directory listing. Next, we'll delete the file \texttt{fun}, \& just for enjoyment, we'll include the \texttt{-i} option to show what that does.
\begin{verbatim}
	[me@linuxbox playground]$ rm -i fun
	rm: remove regular file `fun'?
\end{verbatim}
Enter \texttt{y} at the prompt \& the file is deleted. But let's look at the output of \texttt{ls} now. Notice what happened to \texttt{fun-sym?} Because it's a symbolic link pointing to a now-nonexistent file, the link is broken.
\begin{verbatim}
	[me@linuxbox playground]$ ls -l
	total 8
	drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir1
	lrwxrwxrwx 1 me me
	4 2018-01-16 14:45 dir1-sym -> dir1
	drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir2
	lrwxrwxrwx 1 me me
	3 2018-01-15 15:15 fun-sym -> fun
\end{verbatim}
Most Linux distributions configure \texttt{ls} to display broken links. The presence of a broken link is not in \& of itself dangerous, but it is rather messy. If we try to use a broken link, we will see this:
\begin{verbatim}
	[me@linuxbox playground]$ less fun-sym
	fun-sym: No such file or directory
\end{verbatim}
Let's clean up a little. We'll delete the symbolic links here:
\begin{verbatim}
	[me@linuxbox playground]$ rm fun-sym dir1-sym
	[me@linuxbox playground]$ ls -l
	total 8
	drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir1
	drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir2
\end{verbatim}
1 thing to remember about symbolic links is that most file operations are carried out on the link's target, not the link itself. \texttt{rm} is an exception. When you delete a link, it is the link that is deleted, not the target.

Finally, we will remove our playground. To do this, we will return to our home directory \& use \texttt{rm} with the recursive option (\texttt{-r}) to delete \texttt{playground} \& all of its contents, including its subdirectories.
\begin{verbatim}
	[me@linuxbox playground]$ cd
	[me@linuxbox ~]$ rm -r playground
\end{verbatim}
\textbf{Creating symlinks with the GUI.} The file managers in both GNOME \& KDE provide an easy \& automatic method of creating symbolic links. With GNOME, holding the \textsc{ctrl-shift} keys while dragging a file will create a link rather than copying (or moving) the file. In KDE, a small menu appears whenever a file is dropped, offering a choice of copying, moving, or linking the file.'' -- \cite[pp. 80--82]{Shotts2019}

\subsection{Summing Up}
``We've covered a lot of ground here, \& it will take a while for it all to fully sink in. Perform the playground exercise over \& over until it makes sense. It is important to get hood understanding of basic file manipulation commands \& wildcards. Feel free to expand on the playground exercise by adding more files \& directories, using wildcards to specify files for various operations. The concept of links is a little confusing at 1st, but take the time to learn how they work. They can be a real lifesaver!'' -- \cite[p. 82]{Shotts2019}

%------------------------------------------------------------------------------%

\section{Working with Commands}
``Up to this point, we have seen a series of mysterious commands, each with its own options \& arguments. In this chapter, we will attempt to remove some of that mystery \& even create our own commands. The command introduced in this chapter are as follows:
\begin{enumerate*}
	\item[$\bullet$] \texttt{type}: Indicate how a command name is interpreted.
	\item[$\bullet$] \texttt{which}: Display which executable program will be executed.
	\item[$\bullet$] \texttt{help}: Get help for shell builtins.
	\item[$\bullet$] \texttt{man}: Display a command's manual page.
	\item[$\bullet$] \texttt{apropos}: Display a list of appropriate commands.
	\item[$\bullet$] \texttt{info}: Display a command's info entry.
	\item[$\bullet$] \texttt{whatis}: Display 1-line manual page descriptions.
	\item[$\bullet$] \texttt{alias}: Create an alias for a command.'' -- \cite[p. 83]{Shotts2019}
\end{enumerate*}

\subsection{What Exactly Are Commands?}
``A command can be 1 of 4 different things.
\begin{itemize}
	\item \textbf{An executable program} like all those files we saw in \texttt{/usr/bin}. Within this category, programs can be \textit{compiled binaries} such as programs written in C \& C++, or programs written in \textit{scripting languages} such as the shell, Perl, Python, Ruby, \& so on.
	\item \textbf{A command built into the shell itself.} \texttt{bash} supports a number of commands internally called \textit{shell builtins}. The \texttt{cd} command, e.g., is a shell builtin.
	\item \textbf{A shell function.} Shell functions are miniature shell scripts incorporated into the \textit{environment}. We will cover configuring the environment \& writing shell functions in later chapters, but for now, just be aware that they exist.
	\item \textbf{An alias.} Aliases are commands that we can define ourselves, built from other commands.'' -- \cite[pp. 83--84]{Shotts2019}
\end{itemize}

\subsection{Identifying Commands}
``It is often useful to know exactly which of the 4 kinds of commands is being used, \& Linux provides a couple of ways to find out.'' -- \cite[p. 84]{Shotts2019}

\subsubsection{\texttt{type} -- Display a Command's Type}
``The \texttt{type} command is a shell builtin that displays the kind of command the shell will execute, given a particular command name. It works like this: \texttt{\textbf{type} \textit{command}} where \texttt{command} is the name of the command you want to examine. Here are some examples:
\begin{verbatim}
	[me@linuxbox ~]$ type type
	type is a shell builtin
	[me@linuxbox ~]$ type ls
	ls is aliased to `ls --color=tty'
	[me@linuxbox ~]$ type cp
	cp is /bin/cp
\end{verbatim}
Here we see the results for 3 different commands. Notice the one for \texttt{ls} (taken from a Fedora system) \& how the \texttt{ls} command is actually an alias for the \texttt{ls} command with the \texttt{--color=tty} option added. Now we know why the output from \texttt{ls} is displayed in color!'' -- \cite[pp. 84--85]{Shotts2019}

\subsubsection{\texttt{which} -- Display an Executable's Location}
``Sometimes there is $> 1$ version of an executable program installed on a system. While this is not common on desktop systems, it's not unusual on larger servers. To determine the exact location of a given executable, the \texttt{which} command is used.
\begin{verbatim}
	[me@linuxbox ~]$ which ls
	/bin/ls
\end{verbatim}
\texttt{which} works only for executable programs, not builtins or aliases that are substitutes for actual executable programs. When we try to use \texttt{which} on a shell builtin -- e.g., \texttt{cd} -- we either get no response or get an error message.
\begin{verbatim}
	[me@linuxbox ~]$ which cd
	/usr/bin/which: no cd in
	(/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games)
\end{verbatim}
This result is a fancy way of saying ``command not found''.'' -- \cite[p. 85]{Shotts2019}

\subsection{Getting a Command's Documentation}
``With this knowledge of what a command is, we can now search for the documentation available for each kind of command.'' -- \cite[p. 85]{Shotts2019}

\subsubsection{\texttt{help} -- Get Help for Shell Builtins}
``\texttt{bash} has a built-in help facility available for each of the shell builtins. To use it, type \texttt{help} followed by the name of the shell builtin. Here's an example:
\begin{verbatim}
	[me@linuxbox ~]$ help cd
	cd: cd [-L|[-P [-e]] [-@]] [dir]
	    Change the shell working directory.
	    
	    Change the current directory to DIR.  The default DIR is the value of the
	    HOME shell variable. If DIR is "-", it is converted to $OLDPWD.
	    
	    The variable CDPATH defines the search path for the directory containing
	    DIR.  Alternative directory names in CDPATH are separated by a colon (:).
	    A null directory name is the same as the current directory.  If DIR begins
	    with a slash (/), then CDPATH is not used.
	    
	    If the directory is not found, and the shell option `cdable_vars' is set,
	    the word is assumed to be  a variable name.  If that variable has a value,
	    its value is used for DIR.
	    
	    Options:
	      -L	force symbolic links to be followed: resolve symbolic
	    		links in DIR after processing instances of `..'
	      -P	use the physical directory structure without following
	    		symbolic links: resolve symbolic links in DIR before
	    		processing instances of `..'
	      -e	if the -P option is supplied, and the current working
	    		directory cannot be determined successfully, exit with
	    		a non-zero status
	      -@	on systems that support it, present a file with extended
	    		attributes as a directory containing the file attributes
	    
	    The default is to follow symbolic links, as if `-L' were specified.
	    `..' is processed by removing the immediately previous pathname component
	    back to a slash or the beginning of DIR.
	    
	    Exit Status:
	    Returns 0 if the directory is changed, and if $PWD is set successfully when
	    -P is used; non-zero otherwise.
\end{verbatim}
\textbf{A note on notation.} When square brackets appear in the description of a command's syntax, they indicate optional items. A vertical bar character indicates mutually exclusive items. In the case of the \texttt{cd} command above:
\begin{verbatim}
    cd [-L|[-P[-e]]] [dir]
\end{verbatim}
This notation says that the command \texttt{cd} may be followed optionally by either a \texttt{-L} or a \texttt{-P} \& further, if the \texttt{-P} option is specified the \texttt{-e} option may also be included followed by the optional argument \texttt{dir}.

While the output of \texttt{help} for the \texttt{cd} commands is concise \& accurate, it is by no means tutorial \& as we can see, it also seems to mention a lot of things we haven't talked about yet! Don't worry. We'll get there.'' -- \cite[pp. 85--87]{Shotts2019}

\subsubsection{\texttt{--help} -- Display Usage Information}
``Many executable programs support a \texttt{--help} option that displays a description of the command's supported syntax \& options. E.g.:
\begin{verbatim}
	[me@linuxbox ~]$ mkdir --help
	Usage: mkdir [OPTION]... DIRECTORY...
	Create the DIRECTORY(ies), if they do not already exist.
	
	Mandatory arguments to long options are mandatory for short options too.
	  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
	  -p, --parents     no error if existing, make parent directories as needed
	  -v, --verbose     print a message for each created directory
	  -Z                   set SELinux security context of each created directory
	                         to the default type
	      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
	                         or SMACK security context to CTX
	      --help     display this help and exit
	      --version  output version information and exit
	
	GNU coreutils online help: <https://www.gnu.org/software/coreutils/>
	Full documentation <https://www.gnu.org/software/coreutils/mkdir>
	or available locally via: info '(coreutils) mkdir invocation'
\end{verbatim}
Some programs don't support the \texttt{--help} option, but try it anyway. Often it results in an error message that will reveal the same usage information.'' -- \cite[p. 87]{Shotts2019}

\subsubsection{\texttt{man} -- Display a Program's Manual Page}
``Most executable programs intended for command line use provide a formal piece of documentation called a \textit{manual} or \textit{man page}. A special paging program called \texttt{man} is used to view them. It is used like this: \texttt{\textbf{man} \textit{program}} where \texttt{program} is the name of the command to view.

Man pages vary somewhat in format but generally contain the following:
\begin{enumerate*}
	\item[$\bullet$] A title (the page's name).
	\item[$\bullet$] A synopsis of the command's syntax.
	\item[$\bullet$] A description of the command's purpose.
	\item[$\bullet$] A listing \& description of each of the command's options.
\end{enumerate*}

Man pages, however, do not usually include examples \& are intended as a reference, not a tutorial. As an example, let's try viewing the man page for the \texttt{ls} command.
\begin{verbatim}
	[me@linuxbox ~]$ man ls
\end{verbatim}
On most Linux systems, \texttt{man} uses \texttt{less} to display the manual page, so all of the familiar \texttt{less} commands work while displaying the page.

The ``manual'' that \texttt{man} displays is broken into sections \& covers not only user commands but also system administration commands, programming interfaces, file formats, \& more. Table 5-1 describes the layout of the manual. \textsf{Table 5-1: Man Page Organization. Section : Contents}.
\begin{itemize}
	\item 1: User commands
	\item 2: Programming interfaces for kernel system calls.
	\item 3: Programming interfaces to the C library.
	\item 4: Special files such as device nodes \& drivers.
	\item 5: File formats.
	\item 6: Games \& amusements such as screen savers.
	\item 7: Miscellaneous.
	\item 8: System administration commands.
\end{itemize}
Sometimes we need to refer to a specific section of the manual to find what we are looking for. This is particularly true if we are looking for a file format that is also the name of a command. Without specifying a section number, we will always get the 1st instance of a match, probably in section 1. To specify a section number, we use \texttt{man} like this: \verb|man section search_term|. Here's an example:
\begin{verbatim}
	[me@linuxbox ~]$ man 5 passwd
\end{verbatim}
This will display the man page describing the file format of the \texttt{/etc/passwd} file.'' -- \cite[pp. 87--89]{Shotts2019}

\subsubsection{\texttt{apropos} -- Display Appropriate Commands}
``It is also possible to search the list of man pages for possible matches based on a search term. It's crude but sometimes helpful. Here is an example of a search for man pages using the search term \textit{partition}:
\begin{verbatim}
	[me@linuxbox ~]$ apropos partition
	addpart (8)          - tell the kernel about the existence of a partition
	cfdisk (8)           - display or manipulate a disk partition table
	cgdisk (8)           - Curses-based GUID partition table (GPT) manipulator
	delpart (8)          - tell the kernel to forget about a partition
	fdisk (8)            - manipulate disk partition table
	fixparts (8)         - MBR partition table repair utility
	gdisk (8)            - Interactive GUID partition table (GPT) manipulator
	gparted (8)          - GNOME Partition Editor for manipulating disk partitions.
	parted (8)           - a partition manipulation program
	partprobe (8)        - inform the OS of partition table changes
	partx (8)            - tell the kernel about the presence and numbering of on...
	repart.d (5)         - Partition Definition Files for Automatic Boot-Time Rep...
	resizepart (8)       - tell the kernel about the new size of a partition
	sfdisk (8)           - display or manipulate a disk partition table
	sgdisk (8)           - Command-line GUID partition table (GPT) manipulator fo...
	systemd-gpt-auto-generator (8) - Generator for automatically discovering and ...
	systemd-repart (8)   - Automatically grow and add partitions
	systemd-repart.service (8) - Automatically grow and add partitions
\end{verbatim}
The 1st field in each line of output is the name of the man page, \& the 2nd field shows the section. Note that the \texttt{man} command with the \texttt{-k} option performs the same function as \texttt{apropos}.'' -- \cite[pp. 89--90]{Shotts2019}

\subsubsection{\texttt{whatis} -- Display 1-line Manual Page Descriptions}
``The \texttt{whatis} program displays the name \& a 1-line description of a man page matching a specified keyword.
\begin{verbatim}
	[me@linuxbox ~]$ whatis ls
	ls                  (1) - list directory contents
\end{verbatim}
\textbf{The most brutal man page of them all.} As we have seen, the manual pages supplied with Linux \& other Unix-like systems are intended as reference documentation \& not as tutorials. Many man pages are hard to read, but I think the grand prize for difficulty has got to go to the man page for \texttt{bash}. As I was doing research for this book, I gave the \texttt{bash} man page careful review to ensure that I was covering most of its topics. When printed, it's $> 80$ pages long \& extremely dense, \& its structure makes absolutely no sense to a new user.

On the other hand, it is very accurate \& concise, as well as being extremely complete. So check it out if you dare \& look forward to the day when you can read it \& it all makes sense.'' -- \cite[p. 90]{Shotts2019}

\subsubsection{\texttt{info} -- Display a Program's Info Entry}

%------------------------------------------------------------------------------%

\section{Redirection}

%------------------------------------------------------------------------------%

\section{Seeing the World as the Shell Sees It}

%------------------------------------------------------------------------------%

\section{Advanced Keyboard Tricks}

%------------------------------------------------------------------------------%

\section{Permissions}

%------------------------------------------------------------------------------%

\section{Processes}

%------------------------------------------------------------------------------%

\begin{center}
	\huge Part II: Configuration \& The Environment
\end{center}

\section{The Environment}

%------------------------------------------------------------------------------%

\section{A Gentle Introduction to vi}

%------------------------------------------------------------------------------%

\section{Customizing the Prompt}

%------------------------------------------------------------------------------%

\begin{center}
	\huge Part III: Common Tasks \& Essential Tools
\end{center}

%------------------------------------------------------------------------------%

\section{Package Management}

%------------------------------------------------------------------------------%

\section{Storage Media}

%------------------------------------------------------------------------------%

\section{Networking}

%------------------------------------------------------------------------------%

\section{Searching for Files}

%------------------------------------------------------------------------------%

\section{Archiving \& Backup}

%------------------------------------------------------------------------------%

\section{Regular Expressions}

%------------------------------------------------------------------------------%

\section{Text Processing}

%------------------------------------------------------------------------------%

\section{Formatting Output}

%------------------------------------------------------------------------------%

\section{Printing}

%------------------------------------------------------------------------------%

\section{Compiling Programs}

%------------------------------------------------------------------------------%

\begin{center}
	\huge Part IV: Writing Shell Scripts
\end{center}

%------------------------------------------------------------------------------%

\section{Writing Your 1st Script}

%------------------------------------------------------------------------------%

\section{Starting a Project}

%------------------------------------------------------------------------------%

\section{Top-Down Design}

%------------------------------------------------------------------------------%

\section{Flow Control: Branching with \texttt{if}}

%------------------------------------------------------------------------------%

\section{Reading Keyboard Input}

%------------------------------------------------------------------------------%

\section{Flow Control: Looping with \texttt{while/until}}

%------------------------------------------------------------------------------%

\section{Troubleshooting}

%------------------------------------------------------------------------------%

\section{Flow Control: Branching with \texttt{case}}

%------------------------------------------------------------------------------%

\section{Positional Parameters}

%------------------------------------------------------------------------------%

\section{Flow Control: Looping with \texttt{for}}

%------------------------------------------------------------------------------%

\section{Strings \& Numbers}

%------------------------------------------------------------------------------%

\section{Arrays}

%------------------------------------------------------------------------------%

\section{Exotica}

%------------------------------------------------------------------------------%

\chapter{Miscellaneous}

\section{Calibre}
Official website: \url{https://calibre-ebook.com/}. See also, e.g., \href{https://en.wikipedia.org/wiki/Calibre_(software)}{Wikipedia\texttt{/}Calibre (software)}. Enable Dark Mode in Calibre:
\begin{verbatim}
	$ sudo nano /etc/profile.d/calibre.sh
	
	export CALIBRE_USE_SYSTEM_THEME=1
	$ sudo service gdm restart
\end{verbatim}
\& further customization. \texttt{[inserting]}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]
	
\end{document}