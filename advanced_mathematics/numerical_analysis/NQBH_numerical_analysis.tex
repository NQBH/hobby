\documentclass[oneside]{book}
\usepackage[backend=biber,natbib=true,style=authoryear]{biblatex}
\addbibresource{/home/hong/1_NQBH/reference/bib.bib}
\usepackage[vietnamese,english]{babel}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,mathtools,float,graphicx}
\allowdisplaybreaks
\numberwithin{equation}{section}
\newtheorem{assumption}{Assumption}[chapter]
\newtheorem{conjecture}{Conjecture}[chapter]
\newtheorem{corollary}{Corollary}[chapter]
\newtheorem{definition}{Definition}[chapter]
\newtheorem{example}{Example}[chapter]
\newtheorem{lemma}{Lemma}[chapter]
\newtheorem{notation}{Notation}[chapter]
\newtheorem{principle}{Principle}[chapter]
\newtheorem{problem}{Problem}[chapter]
\newtheorem{proposition}{Proposition}[chapter]
\newtheorem{question}{Question}[chapter]
\newtheorem{remark}{Remark}[chapter]
\newtheorem{theorem}{Theorem}[chapter]
\usepackage[left=0.5in,right=0.5in,top=1.5cm,bottom=1.5cm]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\lhead{\small \textsc{Sect.} ~\thesection}
\rhead{\small \nouppercase{\leftmark}}
\renewcommand{\sectionmark}[1]{\markboth{#1}{}}
\cfoot{\thepage}
\def\labelitemii{$\circ$}

\title{Some Topics in Numerical Analysis}
\author{\selectlanguage{vietnamese} Nguyễn Quản Bá Hồng\footnote{Independent Researcher, Ben Tre City, Vietnam\\e-mail: \texttt{nguyenquanbahong@gmail.com}}}
\date{\today}

\begin{document}
\maketitle
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}
\tableofcontents

%------------------------------------------------------------------------------%

\chapter*{Preface}

A collection of \& some personal notes on Numerical Analysis.

%------------------------------------------------------------------------------%

\chapter{Wikipedia's}

\section{\href{https://en.wikipedia.org/wiki/Numerical_analysis}{Wikipedia\texttt{/}Numerical Analysis}}
\textsf{Fig. Babylonian clay tablet \href{https://en.wikipedia.org/wiki/YBC_7289}{YBC 7289} (c. 1800--1600 BC) with annotations. The approximation of the \href{https://en.wikipedia.org/wiki/Square_root_of_2}{square root of 2} is 4 \href{https://en.wikipedia.org/wiki/Sexagesimal}{sexagesimal} figures, which is about 6 \href{https://en.wikipedia.org/wiki/Decimal}{decimal} figures. $1 + \frac{24}{60} + \frac{51}{60^2} + \frac{10}{60^3} = 1.41421296...$.}

``\textit{Numerical analysis} is the study of \href{https://en.wikipedia.org/wiki/Algorithm}{algorithms} that use numerical \href{https://en.wikipedia.org/wiki/Approximation}{approximation} (as opposed to \href{https://en.wikipedia.org/wiki/Symbolic_computation}{symbolic manipulations}) for the problems of \href{https://en.wikipedia.org/wiki/Mathematical_analysis}{mathematical analysis} (as distinguished from \href{https://en.wikipedia.org/wiki/Discrete_mathematics}{discrete mathematics}). Numerical analysis finds application in all fields of engineering \& the physical sciences, \& in the 21st century also the life \& social sciences, medicine, business \& even the arts. Current growth in computing power has enabled the use of more complex numerical analysis, providing detailed \& realistic mathematical models in science \& engineering. Examples of numerical analysis include: \href{https://en.wikipedia.org/wiki/Ordinary_differential_equation}{ODEs} as found in \href{https://en.wikipedia.org/wiki/Celestial_mechanics}{celestial mechanics} (predicting the motions of planets, stars \& galaxies), \href{https://en.wikipedia.org/wiki/Numerical_linear_algebra}{numerical linear algebra} in data analysis, \& \href{https://en.wikipedia.org/wiki/Stochastic_differential_equation}{stochastic differential equations} \& \href{https://en.wikipedia.org/wiki/Markov_chain}{Markov chains} for simulating living cells in medicine \& biology.

Before modern computers, \href{https://en.wikipedia.org/wiki/Numerical_method}{numerical methods} often relied on hand \href{https://en.wikipedia.org/wiki/Interpolation}{interpolation} formulas, using data from large printed tables. Since the mid 20th century, computers calculate the required functions instead, but many of the same formulas continue to be used in software algorithms.

The numerical point of view goes back to the earliest mathematical writings. A tablet from the \href{https://en.wikipedia.org/wiki/Yale_Babylonian_Collection}{Yale Babylonian Collection} (\href{https://en.wikipedia.org/wiki/YBC_7289}{YBC 7289}), gives a \href{https://en.wikipedia.org/wiki/Sexagesimal}{sexagesimal} numerical approximation of the \href{https://en.wikipedia.org/wiki/Square_root_of_2}{square root of 2}, the length of the \href{https://en.wikipedia.org/wiki/Diagonal}{diagonal} in a \href{https://en.wikipedia.org/wiki/Unit_square}{unit square}.

Numerical analysis continues this long tradition: rather than giving exact symbolic answers translated into digits \& applicable only to real-world measurements, approximate solutions within specified error bounds are used.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis}{Wikipedia\texttt{/}numerical analysis}

\subsection{General Introduction}
``The overall goal of the field of numerical analysis is the design \& analysis of techniques to give approximate but accurate solutions to hard problems, the variety of which is suggested by the following:
\begin{itemize}
	\item Advanced numerical methods are essential in making \href{https://en.wikipedia.org/wiki/Numerical_weather_prediction}{numerical weather prediction} feasible.
	\item Computing the trajectory of a spacecraft requires the accurate numerical solution of a system of ODEs.
	\item Car companies can improve the crash safety of their vehicles by using computer simulations of car crashes. Such simulations essentially consist of solving \href{https://en.wikipedia.org/wiki/Partial_differential_equation}{PDEs} numerically.
	\item \href{https://en.wikipedia.org/wiki/Hedge_fund}{Hedge funds} (private investment funds) use tools from all fields of numerical analysis to attempt to calculate the value of \href{https://en.wikipedia.org/wiki/Stock}{stocks} \& \href{https://en.wikipedia.org/wiki/Derivative_(finance)}{derivatives} more precisely than other market participants.
	\item Airlines use sophisticated optimization algorithms to decide ticket prices, airplane \& crew assignments \& fuel needs. Historically, such algorithms were developed within the overlapping field of \href{https://en.wikipedia.org/wiki/Operations_research}{operations research}.
	\item Insurance companies use numerical programs for \href{https://en.wikipedia.org/wiki/Actuary}{actuarial} analysis.
\end{itemize}
The rest of this section outlines several important themes of numerical analysis.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#General_introduction}{Wikipedia\texttt{/}numerical analysis\texttt{/}general introduction}

\subsubsection{History}
``The field of numerical analysis predates the invention of modern computers by many centuries. \href{https://en.wikipedia.org/wiki/Linear_interpolation}{Linear interpolation} was already in use more than 2000 years ago. Many great mathematicians of the past were preoccupied by numerical analysis, as is obvious from the names of important algorithms like \href{https://en.wikipedia.org/wiki/Newton%27s_method}{Newton's method}, \href{https://en.wikipedia.org/wiki/Lagrange_polynomial}{Lagrange interpolation polynomial}, \href{https://en.wikipedia.org/wiki/Gaussian_elimination}{Gaussian elimination}, or \href{https://en.wikipedia.org/wiki/Euler%27s_method}{Euler's method}.

To facilitate computations by hand, large books were produced with formulas \& tables of data such as interpolation points \& function coefficients. Using these tables, often calculated out to 16 decimal places or more for some functions, one could look up values to plug into the formulas given \& achieve very good numerical estimates of some functions. The canonical work in the field is the \href{https://en.wikipedia.org/wiki/NIST}{NIST} publication edited by \href{https://en.wikipedia.org/wiki/Abramowitz_and_Stegun}{Abramowitz \& Stegun}, a 1000-plus page book of a very large number of commonly used formulas \& functions \& their values at many points. The function values are no longer very useful when a computer is available, but the large listing of formulas can still be very handy.

The \href{https://en.wikipedia.org/wiki/Mechanical_calculator}{mechanical calculator} was also developed as a tool for hand computation. These calculators evolved into electronic computers in the 1940s, \& it was then found that these computers were also useful for administrative purposes. But the invention of the computer also influenced the field of numerical analysis, since now longer \& more complicated calculations could be done.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#History}{Wikipedia\texttt{/}numerical analysis\texttt{/}general introduction\texttt{/}history}

\subsubsection{Direct \& iterative methods}
Given equation $f(x) = g(x)$. For the iterative method, apply the \href{https://en.wikipedia.org/wiki/Bisection_method}{bisection method} to $F(x)\coloneqq f(x) - g(x)$.

\paragraph{Discretization \& numerical integration.} An example of \textit{numerical integration} using a \href{https://en.wikipedia.org/wiki/Riemann_sum}{Riemann sum}, because displacement is the \href{https://en.wikipedia.org/wiki/Integral}{integral} of velocity. Example of ill-conditioned \& well-conditioned problems.

``Direct methods compute the solution to a problem in a finite number of steps. These methods would give the precise answer if they were performed in \href{https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic}{infinite precision arithmetic}. Examples include \href{https://en.wikipedia.org/wiki/Gaussian_elimination}{Gaussian elimination}, the \href{https://en.wikipedia.org/wiki/QR_decomposition}{QR factorization} method for solving \href{https://en.wikipedia.org/wiki/System_of_linear_equations}{systems of linear equations}, \& the \href{https://en.wikipedia.org/wiki/Simplex_method}{simplex method} of \href{https://en.wikipedia.org/wiki/Linear_programming}{linear programming}. In practice, \href{https://en.wikipedia.org/wiki/Floating_point}{finite precision} is used \& the result is an approximation of the true solution (assuming \href{https://en.wikipedia.org/wiki/Numerically_stable}{stability}).

In contrast to direct methods, \href{https://en.wikipedia.org/wiki/Iterative_method}{iterative methods} are not expected to terminate in a finite number of steps. Starting from an initial guess, iterative methods form successive approximations that \href{https://en.wikipedia.org/wiki/Limit_of_a_sequence}{converge} to the exact solution only in the limit. A convergence test, often involving the \href{https://en.wikipedia.org/wiki/Residual_(numerical_analysis)}{residual}, is specified in order to decide when a sufficiently accurate solution has (hopefully) been found. Even using infinite precision arithmetic these methods would not reach the solution within a finite number of steps (in general). Examples include Newton's method, the \href{https://en.wikipedia.org/wiki/Bisection_method}{bisection method}, \& \href{https://en.wikipedia.org/wiki/Jacobi_iteration}{Jacobi iteration}. In computational matrix algebra, iterative methods are generally needed for large problems.

Iterative methods are more common than direct methods in numerical analysis. Some methods are direct in principle but are usually used as though they were not, e.g., \href{https://en.wikipedia.org/wiki/GMRES}{GMRES} \& the \href{https://en.wikipedia.org/wiki/Conjugate_gradient_method}{conjugate gradient method}. For these methods the number of steps needed to obtain the exact solution is so large that an approximation is accepted in the same manner as for an iterative method.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Direct_and_iterative_methods}{Wikipedia\texttt{/}numerical analysis\texttt{/}general introduction\texttt{/}direct \& iterative methods}

\subsubsection{Discretization}
``Furthermore, continuous problems must sometimes be replaced by a discrete problem whose solution is known to approximate that of the continuous problem; this process is called `\href{https://en.wikipedia.org/wiki/Discretization}{discretization}'. E.g., the solution of a \href{https://en.wikipedia.org/wiki/Differential_equation}{differential equation} is a \href{https://en.wikipedia.org/wiki/Function_(mathematics)}{function}. This function must be represented by a finite amount of data, e.g. by its value at a finite number of points at its domain, even though this domain is a \href{https://en.wikipedia.org/wiki/Continuum_(set_theory)}{continuum}.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Discretization}{Wikipedia\texttt{/}numerical analysis\texttt{/}general introduction\texttt{/}discretization}

\subsection{Generation \& propagation of errors}
``The study of errors forms an important part of numerical analysis. There are several ways in which error can be introduced in the solution of the problem.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Generation_and_propagation_of_errors}{Wikipedia\texttt{/}numerical analysis\texttt{/}generation \& propagation of errors}

\subsubsection{Round-off}
``\href{https://en.wikipedia.org/wiki/Round-off_error}{Round-off errors} arise because it is impossible to represent all \href{https://en.wikipedia.org/wiki/Real_number}{real numbers} exactly on a machine with finite memory (which is what all practical \href{https://en.wikipedia.org/wiki/Digital_computer}{digital computers} are).'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Round-off}{Wikipedia\texttt{/}numerical analysis\texttt{/}generation \& propagation of errors\texttt{/}round-off}

\subsubsection{Truncation \& discretization error}
``\href{https://en.wikipedia.org/wiki/Truncation_error}{Truncation errors} are committed when an iterative method is terminated or a mathematical procedure is approximated \& the approximate solution differs from the exact solution. Similarly, discretization includes a \href{https://en.wikipedia.org/wiki/Discretization_error}{discretization error} because the solution of the discrete problem does not coincide with the solution of the continuous problem.'' [$\ldots$]

``Once an error is generated, it propagates through the calculation. E.g., the operation $+$ on a computer is inexact. A calculation of the type $a + b + c + d + e$ is even more inexact.

A truncation error is created when a mathematical procedure is approximated. To integrate a function exactly, an infinite sum of regions must be found, but numerically only a finite sum of regions can be found, \& hence the approximation of the exact solution. Similarly, to differentiate a function, the differential element approaches zero, but numerically only a nonzero value of the differential element can be chosen.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Truncation_and_discretization_error}{Wikipedia\texttt{/}numerical analysis\texttt{/}generation \& propagation of errors\texttt{/}truncation \& discretization error}

\subsubsection{Numerical stability \& well-posed problems}
``\href{https://en.wikipedia.org/wiki/Numerical_stability}{Numerical stability} is a notion in numerical analysis. An algorithm is called `numerically stable' if an error, whatever its cause, does not grow to be much larger during the calculation. This happens if the problem is `\href{https://en.wikipedia.org/wiki/Condition_number}{well-conditioned}', meaning that the solution changes by only a small amount if the problem data are changed by a small amount. To the contrary, if a problem is `ill-conditioned', then any small error in the data will grow to be a large error.

Both the original problem \& the algorithm used to solve that problem can be `well-conditioned' or `ill-conditioned', \& any combination is possible.

So an algorithm that solves a well-conditioned problem may be either numerically stable or numerically unstable. An art of numerical analysis is to find a stable algorithm for solving a well-posed mathematical problem. E.g., computing $\sqrt{2}$ (which is roughly 1.41421) is a well-posed problem. Many algorithms solve this problem by starting with an initial approximation $x_0$ to $\sqrt{2}$, e.g., $x_0 = 1.4$, \& then computing improved guesses $x_1,x_2$, etc. 1 such method is the famous \href{https://en.wikipedia.org/wiki/Babylonian_method}{Babylonian method}, which is given by $x_{k+1} = \frac{x_k}{2} + \frac{1}{x_k}$. Another method, called `method X', is given by $x_{k+1} = (x_k^2 - 2)^2 + x_k$.'' \textsf{Table. A few iterations of each scheme are calculated with initial guesses $x_0 = 1.4$ \& $x_0 = 1.42$.} ``Observe that the Babylonian method converges quickly regardless of the initial guess, whereas Method X converges extremely slowly with initial guess $x_0 = 1.4$ \& diverges for initial guess $x_0 = 1.42$. Hence, the Babylonian method is numerically stable, while Method X is numerically unstable.

\textbf{Numerical stability} is affected by the number of the significant digits the machine keeps. If a machine is used that keeps only the 4 most significant decimal digits, a good example on loss of significance can be given by the 2 equivalent functions
\begin{align*}
	f(x) = x\left(\sqrt{x + 1} - \sqrt{x}\right),\ g(x) = \frac{x}{\sqrt{x + 1} + \sqrt{x}}.
\end{align*}
Comparing the results of
\begin{align*}
	f(500) = 500(\sqrt{501} - \sqrt{500})\approx 500(22.38 - 22.36) = 500\cdot 0.02 = 10,\ g(500) = \frac{500}{\sqrt{501} + \sqrt{500}}\approx\frac{500}{22.38 + 22.36} = \frac{500}{44.74} = 11.17,
\end{align*}
by comparing the 2 results above, it is clear that \href{https://en.wikipedia.org/wiki/Loss_of_significance}{loss of significance} (caused here by \href{https://en.wikipedia.org/wiki/Catastrophic_cancellation}{catastrophic cancellation} from subtracting approximations to the nearby numbers $\sqrt{501}$ \& $\sqrt{500}$, despite the subtraction being computed exactly) has a huge effect on the results, even though both function are equivalent.'' [$\ldots$] The desired value, computed using infinite precision, is $11.174755...$'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Numerical_stability_and_well-posed_problems}{Wikipedia\texttt{/}numerical analysis\texttt{/}generation \& propagation of errors\texttt{/}numerical stability \& well-posed problems}

\subsection{Areas of Study}
``The field of numerical analysis includes many sub-disciplines. Some of the major ones are:'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Areas_of_study}{Wikipedia\texttt{/}numerical analysis\texttt{/}areas of study}

\subsubsection{Computing values of functions}
``1 of the simplest problems is the evaluation of a function at a given point. The most straightforward approach, of just plugging in the number in the formula is sometimes not very efficient. For polynomials, a better approach is using the \href{https://en.wikipedia.org/wiki/Horner_scheme}{Horner scheme}, since it reduces the necessary number of multiplications \& additions. Generally, it is important to estimate \& control \href{https://en.wikipedia.org/wiki/Round-off_error}{round-off errors} arising from the use of \href{https://en.wikipedia.org/wiki/Floating_point}{floating point} arithmetic.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Computing_values_of_functions}{Wikipedia\texttt{/}numerical analysis\texttt{/}areas of study\texttt{/}computing values of functions}

\subsubsection{Interpolation, extrapolation, \& regression}
\begin{itemize}
	\item \textsf{\textbf{Interpolation.} Observing that the temperature varies from $20^\circ$ C at 1:00 to $14^\circ$ C at 3:00, a linear interpolation of this data would conclude that it was $17^\circ$ C at 2:00 \& $18.5^\circ$ C at 1:30 pm.}
	\item \textsf{\textbf{Extrapolation.} If the \href{https://en.wikipedia.org/wiki/Gross_domestic_product}{gross domestic product} of a country has been growing an average of 5\% per year \& was 100 billion last year, it might extrapolated that it will be 105 billion this year.}
	\item \textsf{\textbf{Regression.} In linear regressions, given $n$ points, a line is computed that passes as close as possible to those $n$ points.}
	\item \textsf{\textbf{Optimization.} Suppose lemonade is sold at a \href{https://en.wikipedia.org/wiki/Lemonade_stand}{lemonade stand}, at \$1.00 per glass, that 197 glasses of lemonade can be sold per day, \& that for each increase of $0.01$, 1 less glass of lemonade will be sold per day. If \$1.485 could be charged, profit would be maximized, but due to the constraint of having to charge a whole-cent amount, charging \$1.48 or \$1.49 per glass will both yield the maximum income of \$220.52 per day.}
	\item \textsf{\textbf{Differential equation.} If 100 fans are set up to blow air from 1 end of the room to the other \& then a feather is dropped into the wind, what happens? The feather will follow the air currents, which may be very complex. 1 approximation is to measure the speed at which the air is blowing near the feather every second, \& advance the simulated feather as if it were moving in a straight line at the same speed for 1 second, before measuring the wind speed again. This is called the \href{https://en.wikipedia.org/wiki/Euler_method}{Euler method} for solving an ODE.}
\end{itemize}
``\href{https://en.wikipedia.org/wiki/Interpolation}{Interpolation} solves the following problem: given the value of some unknown function at a number of points, what value does that function have at some other point between the given points?

\href{https://en.wikipedia.org/wiki/Extrapolation}{Extrapolation} is very similar to interpolation, except that now the value of the unknown function at at point which is outside the given points must be found.

\href{https://en.wikipedia.org/wiki/Regression_analysis}{Regression} is also similar, but it takes into account that the data is imprecise. Given some points, \& a measurement of the value of some function at these points (with an error), the unknown function can be found. The \href{https://en.wikipedia.org/wiki/Numerical_methods_for_linear_least_squares}{least squares}-method is 1 way to achieve this.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Interpolation,_extrapolation,_and_regression}{Wikipedia\texttt{/}numerical analysis\texttt{/}areas of study\texttt{/}interpolation, extrapolation, \& regression}

\subsubsection{Solving equations \& systems of equations}
``Another fundamental problem is computing the solution of some given equation. 2 cases are commonly distinguished, depending on whether the equation is linear or not. E.g., the equation $2x + 5 = 3$ is linear while $2x^2 + 5 = 3$ is not.

Much effort has been put in the development of methods for solving \href{https://en.wikipedia.org/wiki/Systems_of_linear_equations}{systems of linear equations}. Standard direct methods, i.e., methods that use some \href{https://en.wikipedia.org/wiki/Matrix_decomposition}{matrix decomposition} are \href{https://en.wikipedia.org/wiki/Gaussian_elimination}{Gaussian elimination}, \href{https://en.wikipedia.org/wiki/LU_decomposition}{LU decomposition}, \href{https://en.wikipedia.org/wiki/Cholesky_decomposition}{Cholesky decomposition} for \href{https://en.wikipedia.org/wiki/Symmetric_matrix}{symmetric} (or \href{https://en.wikipedia.org/wiki/Hermitian_matrix}{hermitian}) \& \href{https://en.wikipedia.org/wiki/Positive-definite_matrix}{positive-definite matrix}, \& \href{https://en.wikipedia.org/wiki/QR_decomposition}{QR decomposition} for non-square matrices. Iterative methods such as the \href{https://en.wikipedia.org/wiki/Jacobi_method}{Jacobi method}, \href{https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method}{Gauss--Seidel method}, \href{https://en.wikipedia.org/wiki/Successive_over-relaxation}{successive over-relaxation} \& \href{https://en.wikipedia.org/wiki/Conjugate_gradient_method}{conjugate gradient method} are usually preferred for large systems. General iterative methods can be developed using a \href{https://en.wikipedia.org/wiki/Matrix_splitting}{matrix splitting}.

\href{https://en.wikipedia.org/wiki/Root-finding_algorithm}{Root-finding algorithms} are used to solve nonlinear equations (they are so named since a root of a function is an argument for which the function yields zero). If the function is \href{https://en.wikipedia.org/wiki/Derivative}{differentiable} \& the derivative is known, then Newton's method is a popular choice. \href{https://en.wikipedia.org/wiki/Linearization}{Linearization} is another technique for solving nonlinear equations.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Solving_equations_and_systems_of_equations}{Wikipedia\texttt{/}numerical analysis\texttt{/}areas of study\texttt{/}solving equations \& systems of equations}

\subsubsection{Solving eigenvalue or singular value problems}
``Several important problems can be phrased in terms of \href{https://en.wikipedia.org/wiki/Eigenvalue_decomposition}{eigenvalue decompositions} or \href{https://en.wikipedia.org/wiki/Singular_value_decomposition}{singular value decompositions}. E.g., the \href{https://en.wikipedia.org/wiki/Image_compression}{spectral image compression} algorithm is based on the singular value decomposition. The corresponding tool in statistics is called \href{https://en.wikipedia.org/wiki/Principal_component_analysis}{principal component analysis}.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Solving_eigenvalue_or_singular_value_problems}{Wikipedia\texttt{/}numerical analysis\texttt{/}areas of study\texttt{/}solving eigenvalue or singular value problems}

\subsubsection{Optimization}
``Main article: \href{https://en.wikipedia.org/wiki/Mathematical_optimization}{Wikipedia\texttt{/}mathematical optimization}. Optimization problems ask for the point at which a given function is maximized (or minimized). Often, the point also has to satisfy some \href{https://en.wikipedia.org/wiki/Constraint_(mathematics)}{constraints}.

The field of optimization is further split in several subfields, depending on the form of the \href{https://en.wikipedia.org/wiki/Objective_function}{objective function} \& the constraint. E.g., \href{https://en.wikipedia.org/wiki/Linear_programming}{linear programming} deals with the case that both the objective function \& the constraints are linear. A famous method in linear programming is the \textit{simplex method}.

The method of \href{https://en.wikipedia.org/wiki/Lagrange_multipliers}{Lagrange multipliers} can be used to reduce optimization problems with constraints to unconstrained optimization problems.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Optimization}{Wikipedia\texttt{/}numerical analysis\texttt{/}areas of study\texttt{/}optimization}

\subsubsection{Evaluating integrals}
``Main article: \href{https://en.wikipedia.org/wiki/Numerical_integration}{Numerical integration}. Numerical integration, in some instances also known as numerical \href{https://en.wikipedia.org/wiki/Quadrature_(mathematics)}{quadrature}, asks for the value of a definite \href{https://en.wikipedia.org/wiki/Integral}{integral}. Popular methods use 1 of the \href{https://en.wikipedia.org/wiki/Newton%E2%80%93Cotes_formulas}{Newton--Cotes formulas} (like the midpoint rule or \href{https://en.wikipedia.org/wiki/Simpson%27s_rule}{Simpson's rule}) or \href{https://en.wikipedia.org/wiki/Gaussian_quadrature}{Gaussian quadrature}. These methods rely on a ``divide \& conquer'' strategy, whereby an integral on a relatively large set is broken down into integrals on smaller sets. In higher dimensions, where these methods become prohibitively expensive in terms of computational effort, one may use \href{https://en.wikipedia.org/wiki/Monte_Carlo_method}{Monte Carlo} or \href{https://en.wikipedia.org/wiki/Quasi-Monte_Carlo_method}{quasi-Monte Carlo mehtods} (see \href{https://en.wikipedia.org/wiki/Monte_Carlo_integration}{Monte Carlo integration}), or, in modestly large dimensions, the method of \href{https://en.wikipedia.org/wiki/Sparse_grid}{sparse grids}.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Evaluating_integrals}{Wikipedia\texttt{/}numerical analysis\texttt{/}areas of study\texttt{/}evaluating integrals}

\subsubsection{Differential equations}
``Main articles: \href{https://en.wikipedia.org/wiki/Numerical_ordinary_differential_equations}{Wikipedia\texttt{/}numerical ODEs} \& \href{https://en.wikipedia.org/wiki/Numerical_partial_differential_equations}{Wikipedia\texttt{/}numerical PDEs}. Numerical analysis is also concerned with computing (in an approximate way) the solution of differential equations, both ODEs \& PDEs.

PDEs are solved by 1st discretizing the equation, bringing it into a finite-dimensional subspace. This can be done by a \href{https://en.wikipedia.org/wiki/Finite_element_method}{FEM}, a \href{https://en.wikipedia.org/wiki/Finite_difference}{FDM}, or (particularly in engineering) a \href{https://en.wikipedia.org/wiki/Finite_volume_method}{FVM}. The theoretical justification of these methods often involves theorems from \href{https://en.wikipedia.org/wiki/Functional_analysis}{functional analysis}. This reduces the problem to the solution of an algebraic equation.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Differential_equations}{Wikipedia\texttt{/}numerical analysis\texttt{/}areas of study\texttt{/}differential equations}

\subsection{Software}
``Main articles: \href{https://en.wikipedia.org/wiki/List_of_numerical-analysis_software}{Wikipedia\texttt{/}list of numerical-analysis software} \& \href{https://en.wikipedia.org/wiki/Comparison_of_numerical-analysis_software}{Wikipedia\texttt{/}comparison of numerical-analysis software}. Since the late 20th century, most algorithms are implemented in a variety of programming languages. The \href{https://en.wikipedia.org/wiki/Netlib}{Netlib} repository contains various collections of software routines for numerical problems, mostly in \href{https://en.wikipedia.org/wiki/Fortran}{Fortran} \& \href{https://en.wikipedia.org/wiki/C_(programming_language)}{C}. Commercial products implementing many different numerical algorithms include the \href{https://en.wikipedia.org/wiki/IMSL_Numerical_Libraries}{IMSL} \& \href{https://en.wikipedia.org/wiki/Numerical_Algorithms_Group}{NAG} libraries; a \href{https://en.wikipedia.org/wiki/Free_software}{free-software} alternative is the \href{https://en.wikipedia.org/wiki/GNU_Scientific_Library}{GNU Scientific Library}.

Over the years the \href{https://en.wikipedia.org/wiki/Royal_Statistical_Society}{Royal Statistical Society} published numerous algorithms in its \href{https://en.wikipedia.org/wiki/Journal_of_the_Royal_Statistical_Society,_Series_C_(Applied_Statistics)}{\textit{Applied Statistic}s} (\href{https://jblevins.org/mirror/amiller/#apstat}{code for these ``AS'' function}); \href{https://en.wikipedia.org/wiki/Association_for_Computing_Machinery}{ACM} similarly, in its \href{https://en.wikipedia.org/wiki/Transactions_on_Mathematical_Software}{\textit{Transactions on Mathematical Software}} (\href{https://jblevins.org/mirror/amiller/#toms}{``TOMS'' code}). The \href{https://en.wikipedia.org/wiki/Naval_Surface_Warfare_Center}{Naval Surface Warfare Center} several times published its \href{https://web.archive.org/web/20201009001919/https://apps.dtic.mil/sti/pdfs/ADA476840.pdf}{\textit{Library of Mathematics Subroutines}} (\href{https://jblevins.org/mirror/amiller/#nswc}{code}).

There are several popular numerical computing applications such as \href{https://en.wikipedia.org/wiki/MATLAB}{MATLAB}, \href{https://en.wikipedia.org/wiki/TK_Solver}{TK Solver}, \href{https://en.wikipedia.org/wiki/S-PLUS}{S-PLUS}, \& \href{https://en.wikipedia.org/wiki/IDL_(programming_language)}{IDL} as well as free \& open source alternatives such as \href{https://en.wikipedia.org/wiki/FreeMat}{FreeMat}, \href{https://en.wikipedia.org/wiki/Scilab}{Scilab}, \href{GNU Octave} (similar to MATLAB), \& \href{https://en.wikipedia.org/wiki/IT%2B%2B}{IT++} (a C++ library). There are also programming languages such as \href{https://en.wikipedia.org/wiki/R_(programming_language)}{R} (similar to S-PLUS), \href{https://en.wikipedia.org/wiki/Julia_(programming_language)}{Julia}, \& \href{https://en.wikipedia.org/wiki/Python_(programming_language)}{Python} with libraries such as \href{https://en.wikipedia.org/wiki/NumPy}{NumPy}, \href{https://en.wikipedia.org/wiki/SciPy}{SciPy} \& \href{https://en.wikipedia.org/wiki/SymPy}{SymPy}. Performance varies widely: while vector \& matrix operations are usually fast, scalar loops may vary in speed by more than an order of magnitude.

Many \href{https://en.wikipedia.org/wiki/Computer_algebra_system}{computer algebra systems} such as \href{https://en.wikipedia.org/wiki/Mathematica}{Mathematica} also benefit from the availability of \href{https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic}{arbitrary-precision arithmetic} which can provide more accurate results.

Also, any \href{https://en.wikipedia.org/wiki/Spreadsheet}{spreadsheet} \href{https://en.wikipedia.org/wiki/Software}{software} can be used to solve simple problems relating to numerical analysis. \href{https://en.wikipedia.org/wiki/Microsoft_Excel}{Excel}, e.g., has hundreds of \href{https://en.wikipedia.org/wiki/Microsoft_Excel#Functions}{available functions}, including for matrices, which may be used in conjunction with its \href{https://en.wikipedia.org/wiki/Microsoft_Excel#Add-ins}{built in ``solver''}.'' -- \href{https://en.wikipedia.org/wiki/Numerical_analysis#Software}{Wikipedia\texttt{/}numerical analysis\texttt{/}software}

%------------------------------------------------------------------------------%

\chapter{Numerical Analysts}

\section{Alfio Quarteroni}
``\textit{Alfio Quarteroni} (May 30, 1952) is an Italian mathematician.'' -- \href{https://en.wikipedia.org/wiki/Alfio_Quarteroni}{Wikipedia\texttt{/}Alfio Quarteroni}

%------------------------------------------------------------------------------%

\chapter{FDM}

%------------------------------------------------------------------------------%

\chapter{FEM}

%------------------------------------------------------------------------------%

\chapter{FVM}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]
	
\end{document}