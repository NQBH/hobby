\documentclass{article}
\usepackage[backend=biber,natbib=true,style=alphabetic,maxbibnames=10]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[utf8]{vietnam}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,float,graphicx,mathtools}
\allowdisplaybreaks
\newtheorem{assumption}{Assumption}
\newtheorem{baitoan}{Bài toán}
\newtheorem{cauhoi}{Câu hỏi}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{dangtoan}{Dạng toán}
\newtheorem{definition}{Definition}
\newtheorem{dinhly}{Định lý}
\newtheorem{dinhnghia}{Định nghĩa}
\newtheorem{example}{Example}
\newtheorem{ghichu}{Ghi chú}
\newtheorem{hequa}{Hệ quả}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{lemma}{Lemma}
\newtheorem{luuy}{Lưu ý}
\newtheorem{nhanxet}{Nhận xét}
\newtheorem{notation}{Notation}
\newtheorem{note}{Note}
\newtheorem{principle}{Principle}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{vidu}{Ví dụ}
\usepackage[left=1cm,right=1cm,top=5mm,bottom=5mm,footskip=4mm]{geometry}
\def\labelitemii{$\circ$}
\DeclareRobustCommand{\divby}{%
	\mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}

\title{Some Topics in Elementary Computer Science}
\author{Nguyễn Quản Bá Hồng\footnote{Independent Researcher, Ben Tre City, Vietnam\\e-mail: \texttt{nguyenquanbahong@gmail.com}; website: \url{https://nqbh.github.io}.}}
\date{\today}

\begin{document}
\maketitle
\begin{abstract}
	
\end{abstract}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{3}
\tableofcontents

%------------------------------------------------------------------------------%

\section{Algorithm \& Analysis of Algorithm --  Thuật Toán \& Phân Tích Thuật Toán}
See, e.g, \cite[Chuyên đề 1, pp. 5--12]{TLGK_chuyen_Tin_quyen_1}.

\subsection{Algorithm -- Thuật Toán}

\begin{definition}
	``In mathemmatics \& computer science, an \emph{algorithm} is a finite sequence of \href{https://en.wikipedia.org/wiki/Mathematical_proof#Nature_and_purpose}{rigorous} instructions, typically used to solve a class of specific \href{https://en.wikipedia.org/wiki/Computational_problem}{computational problems} or to perform a \href{https://en.wikipedia.org/wiki/Computation}{computation}.
\end{definition}
Algorithms are used as specifications for performing \href{https://en.wikipedia.org/wiki/Calculation}{calculations} \& \href{https://en.wikipedia.org/wiki/Data_processing}{data processing}. More advanced algorithms can use \href{https://en.wikipedia.org/wiki/Conditional_(computer_programming)}{conditionals} to divert the code execution through various routes (referred to as \href{https://en.wikipedia.org/wiki/Automated_decision-making}{automated decision-making}) \& deduce valid \href{https://en.wikipedia.org/wiki/Inference}{inferences} (referred to as \href{https://en.wikipedia.org/wiki/Automated_reasoning}{automated reasoning}), achieving \href{https://en.wikipedia.org/wiki/Automation}{automation} eventually. Using human characteristics as descriptors of machines in metaphorical ways as already practiced by \href{https://en.wikipedia.org/wiki/Alan_Turing}{Alan Turing} with terms e.g., ``memory'', ``search'', \& ``stimulus''.

In contrast, a \href{https://en.wikipedia.org/wiki/Heuristic_(computer_science)}{heurtistic} is an approach to problem solving that may not be fully specified or may not guarantee correct or optimal results, especially in problem domains where there is no well-defined correct or optimal result.

As an \href{https://en.wikipedia.org/wiki/Effective_method}{effective method}, an algorithm can be expressed within a finite amount of space \& time, \& in a well-defined formal language for calculating a function. Starting from an initial state \& initial input (perhaps \href{https://en.wikipedia.org/wiki/Empty_string}{empty}), the instructions describe a computation that, when \href{https://en.wikipedia.org/wiki/Execution_(computing)}{executed}, proceeds through a finite number of well-defined successive states, eventually producing ``output'' \& terminating at a final ending state. The transition from 1 state to the next is not necessarily \href{https://en.wikipedia.org/wiki/Deterministic}{deterministic}; some algorithms, known as \href{https://en.wikipedia.org/wiki/Randomized_algorithm}{randomized algorithms}, incorporate random input.'' -- \href{https://en.wikipedia.org/wiki/Algorithm}{Wikipedia\texttt{/}algorithm}

\subsection{Analysis of Algorithm -- Phân Tích Thuật Toán}

\begin{definition}
	``In computer science, the \emph{analysis of algorithms} is the process of finding the \href{https://en.wikipedia.org/wiki/Computational_complexity}{computational complexity} of algorithms -- the amount of time, storage, or other resources needed to execute them.
\end{definition}
Usually, this involves determining a function that relates the size of an algorithm's input to the number of steps it takes (its \href{https://en.wikipedia.org/wiki/Time_complexity}{time complexity}) or the number of storage locations it uses (its \href{https://en.wikipedia.org/wiki/Space_complexity}{space complexity}). An algorithm is said to be efficient when this function's values are small, or grow slowly compared to a growth in the size of the input. Different inputs of the same size may cause the algorithm to have different behavior, so \href{https://en.wikipedia.org/wiki/Best,_worst_and_average_case}{best, worst, \& average case} descriptions might all be of practical interest. When not otherwise specified, the function describing the performance of an algorithm is usually an \href{https://en.wikipedia.org/wiki/Upper_bound}{upper bound}, determined from the worst case inputs to the algorithm.

The term ``analysis of algorithms'' was coined by \href{https://en.wikipedia.org/wiki/Donald_Knuth}{Donald Knuth}. Algorithm analysis is an important part of a broader \href{https://en.wikipedia.org/wiki/Computational_complexity_theory}{computational complexity theory}, which provides theoretical estimates for the resources needed by any algorithm which solves a given \href{https://en.wikipedia.org/wiki/Computational_problem}{computational problem}. These estimates provide an insight into reasonable directions of search for \href{https://en.wikipedia.org/wiki/Algorithmic_efficiency}{efficient algorithms}.

'' -- \href{https://en.wikipedia.org/wiki/Analysis_of_algorithms}{Wikipedia\texttt{/}analysis of algorithms}

%------------------------------------------------------------------------------%

\section{Competitive Programming CP}

%------------------------------------------------------------------------------%

\section{Number Theory}

\begin{definition}
	An integer $a\in\mathbb{Z}$ is called a \emph{factor} or a \emph{divisor} of an integer $b\in\mathbb{Z}$ if $a$ divides $b$ (i.e., $b$ is divisible by $a$). If $a$ is a factor of $b$, we write $a\mid b$, or $b\divby a$, \& otherwise we write $a\nmid b$, or $b\not\,\divby a$.
\end{definition}

\begin{baitoan}[Factor\texttt{/}Divisor -- Ước số]
	Với $n\in\mathbb{Z}$ được nhập từ bàn phím, viết chương trình {\sf Pascal, Python, C\texttt{/}C++} xuất ra tất cả: (a) các ước nguyên dương của $n$. (b) các ước nguyên của $n$.
\end{baitoan}

\begin{baitoan}[Prime factorization -- Phân tích ra thừa số nguyên tố]
	Với $n\in\mathbb{Z}$ được nhập từ bàn phím, viết chương trình {\sf Pascal, Python, C\texttt{/}C++} xuất ra phân tích ra thừa số nguyên tố của $n$. E.g., với $n = 72$, xuất ra \verb|72 = 2^3*3^2|, với $n = 12$, xuất ra \verb|12 = 2^2*3|.
\end{baitoan}
Let $\tau(n)$ denote the number of (positive) divisors of an integer $n\in\mathbb{Z}$. E.g., $\tau(12) = 6$ since the divisors of $12$ are 1, 2, 3, 4, 6, \& 12. To calculate the value of $\tau(n)$, we can use the following formula:
\begin{align*}
	n = \prod_{i=1}^k p_i^{\alpha_i} = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}\Rightarrow\tau(n) = \prod_{i=1}^k (\alpha_i + 1) = (\alpha_1 + 1)(\alpha_2 + 1)\cdots(\alpha_k + 1),\ \forall n\in\mathbb{Z},
\end{align*}
because for each prime $p_i$, there are $\alpha_i + 1$ ways to choose how many times it appears in the factor.

\begin{example}
	$12 = 2^2\cdot3\Rightarrow\tau(12) = (2 + 1)(1 + 1) = 3\cdot2 = 6$.
\end{example}

\begin{baitoan}[$\tau(n)$]
	Với $n\in\mathbb{Z}$ được nhập từ bàn phím, viết chương trình {\sf Pascal, Python, C\texttt{/}C++} xuất ra giá trị của hàm $\tau(n)$ số ước số của $n$.
\end{baitoan}
Let $\sigma(n)$ denote the sum of divisors of an integer $n\in\mathbb{Z}$.

\begin{example}
	$\mbox{\rm Ư}(12)\cap\mathbb{N} = \{1,2,3,4,6,12\}\Rightarrow\sigma(12) = 1 + 2 + 3 + 4 + 6 + 12 = 28$.
\end{example}
To calculate the value of $\sigma(n)$, we can use the following formula:
\begin{align*}
	n = \prod_{i=1}^k p_i^{\alpha_i} = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}\Rightarrow\sigma(n) &= \prod_{i=1}^k\sum_{j=0}^{\alpha_i} p_i^j = \prod_{i=1}^k (1 + p_i + p_i^2 + \cdots + p_i^{\alpha_i}) = \prod_{i=1}^k \frac{p_i^{\alpha_i + 1} - 1}{p_i - 1}\\
	&= \frac{p_1^{\alpha_1 + 1} - 1}{p_1 - 1}\cdot\frac{p_2^{\alpha_2 + 1} - 1}{p_2 - 1}\cdots\frac{p_k^{\alpha_k + 1} - 1}{p_k - 1},\ \forall n\in\mathbb{Z},
\end{align*}
where the latter form is based on the \textit{geometric progression formula}.

\begin{example}
	$12 = 2^2\cdot3\Rightarrow\sigma(12) = \frac{2^3 - 1}{2 - 1}\cdot\frac{3^2 - 1}{3 - 1} = 28$.
\end{example}

\begin{baitoan}[$\sigma(n)$]
	Với $n\in\mathbb{Z}$ được nhập từ bàn phím, viết chương trình {\sf Pascal, Python, C\texttt{/}C++} xuất ra giá trị của hàm $\sigma(n)$ tổng tất cả các ước số của $n$.
\end{baitoan}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]
	
\end{document}